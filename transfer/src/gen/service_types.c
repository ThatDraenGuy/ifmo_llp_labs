/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "service_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *toString_ColumnType(int value) {
  static __thread char buf[16] = {0};
  switch (value) {
  case COLUMN_TYPE_COLUMN_TYPE_INT32:
    return "COLUMN_TYPE_COLUMN_TYPE_INT32";
  case COLUMN_TYPE_COLUMN_TYPE_UINT64:
    return "COLUMN_TYPE_COLUMN_TYPE_UINT64";
  case COLUMN_TYPE_COLUMN_TYPE_FLOAT:
    return "COLUMN_TYPE_COLUMN_TYPE_FLOAT";
  case COLUMN_TYPE_COLUMN_TYPE_STRING:
    return "COLUMN_TYPE_COLUMN_TYPE_STRING";
  case COLUMN_TYPE_COLUMN_TYPE_BOOL:
    return "COLUMN_TYPE_COLUMN_TYPE_BOOL";
  default:
    g_snprintf(buf, 16, "%d", value);
    return buf;
  }
}

/* return the name of the constant */
const char *toString_ArithmethicOperatorValue(int value) {
  static __thread char buf[16] = {0};
  switch (value) {
  case ARITHMETHIC_OPERATOR_VALUE_PLUS:
    return "ARITHMETHIC_OPERATOR_VALUE_PLUS";
  case ARITHMETHIC_OPERATOR_VALUE_MINUS:
    return "ARITHMETHIC_OPERATOR_VALUE_MINUS";
  case ARITHMETHIC_OPERATOR_VALUE_MUL:
    return "ARITHMETHIC_OPERATOR_VALUE_MUL";
  case ARITHMETHIC_OPERATOR_VALUE_DIV:
    return "ARITHMETHIC_OPERATOR_VALUE_DIV";
  default:
    g_snprintf(buf, 16, "%d", value);
    return buf;
  }
}

/* return the name of the constant */
const char *toString_ComparisonOperatorValue(int value) {
  static __thread char buf[16] = {0};
  switch (value) {
  case COMPARISON_OPERATOR_VALUE_EQ:
    return "COMPARISON_OPERATOR_VALUE_EQ";
  case COMPARISON_OPERATOR_VALUE_NEQ:
    return "COMPARISON_OPERATOR_VALUE_NEQ";
  case COMPARISON_OPERATOR_VALUE_LESS:
    return "COMPARISON_OPERATOR_VALUE_LESS";
  case COMPARISON_OPERATOR_VALUE_LEQ:
    return "COMPARISON_OPERATOR_VALUE_LEQ";
  case COMPARISON_OPERATOR_VALUE_GREATER:
    return "COMPARISON_OPERATOR_VALUE_GREATER";
  case COMPARISON_OPERATOR_VALUE_GEQ:
    return "COMPARISON_OPERATOR_VALUE_GEQ";
  default:
    g_snprintf(buf, 16, "%d", value);
    return buf;
  }
}

/* return the name of the constant */
const char *toString_LogicalOperatorValue(int value) {
  static __thread char buf[16] = {0};
  switch (value) {
  case LOGICAL_OPERATOR_VALUE_AND:
    return "LOGICAL_OPERATOR_VALUE_AND";
  case LOGICAL_OPERATOR_VALUE_OR:
    return "LOGICAL_OPERATOR_VALUE_OR";
  case LOGICAL_OPERATOR_VALUE_NOT:
    return "LOGICAL_OPERATOR_VALUE_NOT";
  default:
    g_snprintf(buf, 16, "%d", value);
    return buf;
  }
}

enum _ErrorProperties {
  PROP_ERROR_0,
  PROP_ERROR_ERROR_SOURCE,
  PROP_ERROR_ERROR_TYPE,
  PROP_ERROR_ERROR_CODE,
  PROP_ERROR_ERROR_MESSAGE
};

/* reads a error object */
static gint32 error_read(ThriftStruct *object, ThriftProtocol *protocol,
                         GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Error *this_object = ERROR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->errorSource != NULL) {
          g_free(this_object->errorSource);
          this_object->errorSource = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->errorSource, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_errorSource = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_STRING) {
        if (this_object->errorType != NULL) {
          g_free(this_object->errorType);
          this_object->errorType = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->errorType, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_errorType = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 3:
      if (ftype == T_I64) {
        if ((ret = thrift_protocol_read_i64(protocol, &this_object->errorCode,
                                            error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_errorCode = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 4:
      if (ftype == T_STRING) {
        if (this_object->errorMessage != NULL) {
          g_free(this_object->errorMessage);
          this_object->errorMessage = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->errorMessage, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_errorMessage = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 error_write(ThriftStruct *object, ThriftProtocol *protocol,
                          GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  Error *this_object = ERROR(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "Error", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "errorSource",
                                               T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->errorSource,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "errorType", T_STRING,
                                               2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->errorType,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "errorCode", T_I64, 3,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64(protocol, this_object->errorCode,
                                       error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "errorMessage",
                                               T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->errorMessage,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void error_set_property(GObject *object, guint property_id,
                               const GValue *value, GParamSpec *pspec) {
  Error *self = ERROR(object);

  switch (property_id) {
  case PROP_ERROR_ERROR_SOURCE:
    if (self->errorSource != NULL)
      g_free(self->errorSource);
    self->errorSource = g_value_dup_string(value);
    self->__isset_errorSource = TRUE;
    break;

  case PROP_ERROR_ERROR_TYPE:
    if (self->errorType != NULL)
      g_free(self->errorType);
    self->errorType = g_value_dup_string(value);
    self->__isset_errorType = TRUE;
    break;

  case PROP_ERROR_ERROR_CODE:
    self->errorCode = g_value_get_int64(value);
    self->__isset_errorCode = TRUE;
    break;

  case PROP_ERROR_ERROR_MESSAGE:
    if (self->errorMessage != NULL)
      g_free(self->errorMessage);
    self->errorMessage = g_value_dup_string(value);
    self->__isset_errorMessage = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void error_get_property(GObject *object, guint property_id,
                               GValue *value, GParamSpec *pspec) {
  Error *self = ERROR(object);

  switch (property_id) {
  case PROP_ERROR_ERROR_SOURCE:
    g_value_set_string(value, self->errorSource);
    break;

  case PROP_ERROR_ERROR_TYPE:
    g_value_set_string(value, self->errorType);
    break;

  case PROP_ERROR_ERROR_CODE:
    g_value_set_int64(value, self->errorCode);
    break;

  case PROP_ERROR_ERROR_MESSAGE:
    g_value_set_string(value, self->errorMessage);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void error_instance_init(Error *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->errorSource = NULL;
  object->__isset_errorSource = FALSE;
  object->errorType = NULL;
  object->__isset_errorType = FALSE;
  object->errorCode = 0;
  object->__isset_errorCode = FALSE;
  object->errorMessage = NULL;
  object->__isset_errorMessage = FALSE;
}

static void error_finalize(GObject *object) {
  Error *tobject = ERROR(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->errorSource != NULL) {
    g_free(tobject->errorSource);
    tobject->errorSource = NULL;
  }
  if (tobject->errorType != NULL) {
    g_free(tobject->errorType);
    tobject->errorType = NULL;
  }
  if (tobject->errorMessage != NULL) {
    g_free(tobject->errorMessage);
    tobject->errorMessage = NULL;
  }
}

static void error_class_init(ErrorClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = error_read;
  struct_class->write = error_write;

  gobject_class->finalize = error_finalize;
  gobject_class->get_property = error_get_property;
  gobject_class->set_property = error_set_property;

  g_object_class_install_property(
      gobject_class, PROP_ERROR_ERROR_SOURCE,
      g_param_spec_string("errorSource", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_ERROR_ERROR_TYPE,
      g_param_spec_string("errorType", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_ERROR_ERROR_CODE,
                                  g_param_spec_int64("errorCode", NULL, NULL,
                                                     G_MININT64, G_MAXINT64, 0,
                                                     G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_ERROR_ERROR_MESSAGE,
      g_param_spec_string("errorMessage", NULL, NULL, NULL, G_PARAM_READWRITE));
}

GType error_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(ErrorClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)error_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(Error),
        0, /* n_preallocs */
        (GInstanceInitFunc)error_instance_init,
        NULL, /* value_table */
    };

    type =
        g_type_register_static(THRIFT_TYPE_STRUCT, "ErrorType", &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define ERROR_ERROR_DOMAIN "error_error_quark"
GQuark error_error_quark(void) {
  return g_quark_from_static_string(ERROR_ERROR_DOMAIN);
}

enum _ColumnValueProperties {
  PROP_COLUMN_VALUE_0,
  PROP_COLUMN_VALUE_I32_VAL,
  PROP_COLUMN_VALUE_U64_VAL,
  PROP_COLUMN_VALUE_FLOAT_VAL,
  PROP_COLUMN_VALUE_STRING_VAL,
  PROP_COLUMN_VALUE_BOOL_VAL
};

/* reads a column_value object */
static gint32 column_value_read(ThriftStruct *object, ThriftProtocol *protocol,
                                GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnValue *this_object = COLUMN_VALUE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_I32) {
        if ((ret = thrift_protocol_read_i32(protocol, &this_object->i32_val,
                                            error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_i32_val = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_I64) {
        if ((ret = thrift_protocol_read_i64(protocol, &this_object->u64_val,
                                            error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_u64_val = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 3:
      if (ftype == T_DOUBLE) {
        if ((ret = thrift_protocol_read_double(
                 protocol, &this_object->float_val, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_float_val = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 4:
      if (ftype == T_STRING) {
        if (this_object->string_val != NULL) {
          g_free(this_object->string_val);
          this_object->string_val = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->string_val, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_string_val = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 5:
      if (ftype == T_BOOL) {
        if ((ret = thrift_protocol_read_bool(protocol, &this_object->bool_val,
                                             error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_bool_val = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 column_value_write(ThriftStruct *object, ThriftProtocol *protocol,
                                 GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  ColumnValue *this_object = COLUMN_VALUE(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "ColumnValue",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_i32_val == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "i32_val", T_I32, 1,
                                                 error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32(protocol, this_object->i32_val,
                                         error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_u64_val == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "u64_val", T_I64, 2,
                                                 error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64(protocol, this_object->u64_val,
                                         error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_float_val == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "float_val",
                                                 T_DOUBLE, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double(protocol, this_object->float_val,
                                            error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_string_val == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "string_val",
                                                 T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, this_object->string_val,
                                            error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_bool_val == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "bool_val", T_BOOL,
                                                 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool(protocol, this_object->bool_val,
                                          error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void column_value_set_property(GObject *object, guint property_id,
                                      const GValue *value, GParamSpec *pspec) {
  ColumnValue *self = COLUMN_VALUE(object);

  switch (property_id) {
  case PROP_COLUMN_VALUE_I32_VAL:
    self->i32_val = g_value_get_int(value);
    self->__isset_i32_val = TRUE;
    break;

  case PROP_COLUMN_VALUE_U64_VAL:
    self->u64_val = g_value_get_int64(value);
    self->__isset_u64_val = TRUE;
    break;

  case PROP_COLUMN_VALUE_FLOAT_VAL:
    self->float_val = g_value_get_double(value);
    self->__isset_float_val = TRUE;
    break;

  case PROP_COLUMN_VALUE_STRING_VAL:
    if (self->string_val != NULL)
      g_free(self->string_val);
    self->string_val = g_value_dup_string(value);
    self->__isset_string_val = TRUE;
    break;

  case PROP_COLUMN_VALUE_BOOL_VAL:
    self->bool_val = g_value_get_boolean(value);
    self->__isset_bool_val = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void column_value_get_property(GObject *object, guint property_id,
                                      GValue *value, GParamSpec *pspec) {
  ColumnValue *self = COLUMN_VALUE(object);

  switch (property_id) {
  case PROP_COLUMN_VALUE_I32_VAL:
    g_value_set_int(value, self->i32_val);
    break;

  case PROP_COLUMN_VALUE_U64_VAL:
    g_value_set_int64(value, self->u64_val);
    break;

  case PROP_COLUMN_VALUE_FLOAT_VAL:
    g_value_set_double(value, self->float_val);
    break;

  case PROP_COLUMN_VALUE_STRING_VAL:
    g_value_set_string(value, self->string_val);
    break;

  case PROP_COLUMN_VALUE_BOOL_VAL:
    g_value_set_boolean(value, self->bool_val);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void column_value_instance_init(ColumnValue *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->i32_val = 0;
  object->__isset_i32_val = FALSE;
  object->u64_val = 0;
  object->__isset_u64_val = FALSE;
  object->float_val = 0;
  object->__isset_float_val = FALSE;
  object->string_val = NULL;
  object->__isset_string_val = FALSE;
  object->bool_val = 0;
  object->__isset_bool_val = FALSE;
}

static void column_value_finalize(GObject *object) {
  ColumnValue *tobject = COLUMN_VALUE(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->string_val != NULL) {
    g_free(tobject->string_val);
    tobject->string_val = NULL;
  }
}

static void column_value_class_init(ColumnValueClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = column_value_read;
  struct_class->write = column_value_write;

  gobject_class->finalize = column_value_finalize;
  gobject_class->get_property = column_value_get_property;
  gobject_class->set_property = column_value_set_property;

  g_object_class_install_property(gobject_class, PROP_COLUMN_VALUE_I32_VAL,
                                  g_param_spec_int("i32_val", NULL, NULL,
                                                   G_MININT32, G_MAXINT32, 0,
                                                   G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_COLUMN_VALUE_U64_VAL,
                                  g_param_spec_int64("u64_val", NULL, NULL,
                                                     G_MININT64, G_MAXINT64, 0,
                                                     G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_COLUMN_VALUE_FLOAT_VAL,
                                  g_param_spec_double("float_val", NULL, NULL,
                                                      -INFINITY, INFINITY, 0,
                                                      G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_COLUMN_VALUE_STRING_VAL,
      g_param_spec_string("string_val", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_COLUMN_VALUE_BOOL_VAL,
      g_param_spec_boolean("bool_val", NULL, NULL, FALSE, G_PARAM_READWRITE));
}

GType column_value_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(ColumnValueClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)column_value_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(ColumnValue),
        0, /* n_preallocs */
        (GInstanceInitFunc)column_value_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "ColumnValueType",
                                  &type_info, 0);
  }

  return type;
}

enum _ColumnSchemaProperties {
  PROP_COLUMN_SCHEMA_0,
  PROP_COLUMN_SCHEMA_COLUMN_NAME,
  PROP_COLUMN_SCHEMA_COLUMN_TYPE
};

/* reads a column_schema object */
static gint32 column_schema_read(ThriftStruct *object, ThriftProtocol *protocol,
                                 GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnSchema *this_object = COLUMN_SCHEMA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->columnName != NULL) {
          g_free(this_object->columnName);
          this_object->columnName = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->columnName, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_columnName = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_I32) {
        gint32 ecast0;
        if ((ret = thrift_protocol_read_i32(protocol, &ecast0, error)) < 0)
          return -1;
        xfer += ret;
        this_object->columnType = (ColumnType)ecast0;
        this_object->__isset_columnType = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 column_schema_write(ThriftStruct *object,
                                  ThriftProtocol *protocol, GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  ColumnSchema *this_object = COLUMN_SCHEMA(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "ColumnSchema",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "columnName", T_STRING,
                                               1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->columnName,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "columnType", T_I32, 2,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32(
           protocol, (gint32)this_object->columnType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void column_schema_set_property(GObject *object, guint property_id,
                                       const GValue *value, GParamSpec *pspec) {
  ColumnSchema *self = COLUMN_SCHEMA(object);

  switch (property_id) {
  case PROP_COLUMN_SCHEMA_COLUMN_NAME:
    if (self->columnName != NULL)
      g_free(self->columnName);
    self->columnName = g_value_dup_string(value);
    self->__isset_columnName = TRUE;
    break;

  case PROP_COLUMN_SCHEMA_COLUMN_TYPE:
    self->columnType = g_value_get_int(value);
    self->__isset_columnType = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void column_schema_get_property(GObject *object, guint property_id,
                                       GValue *value, GParamSpec *pspec) {
  ColumnSchema *self = COLUMN_SCHEMA(object);

  switch (property_id) {
  case PROP_COLUMN_SCHEMA_COLUMN_NAME:
    g_value_set_string(value, self->columnName);
    break;

  case PROP_COLUMN_SCHEMA_COLUMN_TYPE:
    g_value_set_int(value, self->columnType);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void column_schema_instance_init(ColumnSchema *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->columnName = NULL;
  object->__isset_columnName = FALSE;
  object->__isset_columnType = FALSE;
}

static void column_schema_finalize(GObject *object) {
  ColumnSchema *tobject = COLUMN_SCHEMA(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->columnName != NULL) {
    g_free(tobject->columnName);
    tobject->columnName = NULL;
  }
}

static void column_schema_class_init(ColumnSchemaClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = column_schema_read;
  struct_class->write = column_schema_write;

  gobject_class->finalize = column_schema_finalize;
  gobject_class->get_property = column_schema_get_property;
  gobject_class->set_property = column_schema_set_property;

  g_object_class_install_property(
      gobject_class, PROP_COLUMN_SCHEMA_COLUMN_NAME,
      g_param_spec_string("columnName", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_COLUMN_SCHEMA_COLUMN_TYPE,
      g_param_spec_int("columnType", NULL, NULL, 0, 4, 0, G_PARAM_READWRITE));
}

GType column_schema_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(ColumnSchemaClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)column_schema_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(ColumnSchema),
        0, /* n_preallocs */
        (GInstanceInitFunc)column_schema_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "ColumnSchemaType",
                                  &type_info, 0);
  }

  return type;
}

enum _TableSchemaProperties {
  PROP_TABLE_SCHEMA_0,
  PROP_TABLE_SCHEMA_TABLE_NAME,
  PROP_TABLE_SCHEMA_COLUMNS
};

/* reads a table_schema object */
static gint32 table_schema_read(ThriftStruct *object, ThriftProtocol *protocol,
                                GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TableSchema *this_object = TABLE_SCHEMA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->tableName != NULL) {
          g_free(this_object->tableName);
          this_object->tableName = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->tableName, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_tableName = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_LIST) {
        {
          guint32 size;
          guint32 i;
          ThriftType element_type;

          if ((ret = thrift_protocol_read_list_begin(protocol, &element_type,
                                                     &size, error)) < 0)
            return -1;
          xfer += ret;

          /* iterate through list elements */
          for (i = 0; i < size; i++) {
            ColumnSchema *_elem1 = NULL;
            if (_elem1 != NULL) {
              g_object_unref(_elem1);
            }
            _elem1 = g_object_new(TYPE_COLUMN_SCHEMA, NULL);
            if ((ret = thrift_struct_read(THRIFT_STRUCT(_elem1), protocol,
                                          error)) < 0) {
              g_object_unref(_elem1);
              return -1;
            }
            xfer += ret;
            g_ptr_array_add(this_object->columns, _elem1);
          }
          if ((ret = thrift_protocol_read_list_end(protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
        this_object->__isset_columns = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 table_schema_write(ThriftStruct *object, ThriftProtocol *protocol,
                                 GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  TableSchema *this_object = TABLE_SCHEMA(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "TableSchema",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "tableName", T_STRING,
                                               1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->tableName,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "columns", T_LIST, 2,
                                               error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i2;

    if ((ret = thrift_protocol_write_list_begin(
             protocol, T_STRUCT,
             (gint32)(this_object->columns ? this_object->columns->len : 0),
             error)) < 0)
      return -1;
    xfer += ret;
    for (i2 = 0; i2 < (this_object->columns ? this_object->columns->len : 0);
         i2++) {
      if ((ret = thrift_struct_write(
               THRIFT_STRUCT(
                   (g_ptr_array_index((GPtrArray *)this_object->columns, i2))),
               protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void table_schema_set_property(GObject *object, guint property_id,
                                      const GValue *value, GParamSpec *pspec) {
  TableSchema *self = TABLE_SCHEMA(object);

  switch (property_id) {
  case PROP_TABLE_SCHEMA_TABLE_NAME:
    if (self->tableName != NULL)
      g_free(self->tableName);
    self->tableName = g_value_dup_string(value);
    self->__isset_tableName = TRUE;
    break;

  case PROP_TABLE_SCHEMA_COLUMNS:
    if (self->columns != NULL)
      g_ptr_array_unref(self->columns);
    self->columns = g_value_dup_boxed(value);
    self->__isset_columns = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void table_schema_get_property(GObject *object, guint property_id,
                                      GValue *value, GParamSpec *pspec) {
  TableSchema *self = TABLE_SCHEMA(object);

  switch (property_id) {
  case PROP_TABLE_SCHEMA_TABLE_NAME:
    g_value_set_string(value, self->tableName);
    break;

  case PROP_TABLE_SCHEMA_COLUMNS:
    g_value_set_boxed(value, self->columns);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void table_schema_instance_init(TableSchema *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->columns = g_ptr_array_new_with_free_func(g_object_unref);
  object->__isset_columns = FALSE;
}

static void table_schema_finalize(GObject *object) {
  TableSchema *tobject = TABLE_SCHEMA(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->tableName != NULL) {
    g_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->columns != NULL) {
    g_ptr_array_unref(tobject->columns);
    tobject->columns = NULL;
  }
}

static void table_schema_class_init(TableSchemaClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = table_schema_read;
  struct_class->write = table_schema_write;

  gobject_class->finalize = table_schema_finalize;
  gobject_class->get_property = table_schema_get_property;
  gobject_class->set_property = table_schema_set_property;

  g_object_class_install_property(
      gobject_class, PROP_TABLE_SCHEMA_TABLE_NAME,
      g_param_spec_string("tableName", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_TABLE_SCHEMA_COLUMNS,
                                  g_param_spec_boxed("columns", NULL, NULL,
                                                     G_TYPE_PTR_ARRAY,
                                                     G_PARAM_READWRITE));
}

GType table_schema_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(TableSchemaClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)table_schema_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(TableSchema),
        0, /* n_preallocs */
        (GInstanceInitFunc)table_schema_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "TableSchemaType",
                                  &type_info, 0);
  }

  return type;
}

enum _ArithmethicOperatorProperties {
  PROP_ARITHMETHIC_OPERATOR_0,
  PROP_ARITHMETHIC_OPERATOR_OPERATOR,
  PROP_ARITHMETHIC_OPERATOR_OPERAND_TYPE
};

/* reads a arithmethic_operator object */
static gint32 arithmethic_operator_read(ThriftStruct *object,
                                        ThriftProtocol *protocol,
                                        GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ArithmethicOperator *this_object = ARITHMETHIC_OPERATOR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_I32) {
        gint32 ecast3;
        if ((ret = thrift_protocol_read_i32(protocol, &ecast3, error)) < 0)
          return -1;
        xfer += ret;
        this_object->operator=(ArithmethicOperatorValue) ecast3;
        this_object->__isset_operator = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_I32) {
        gint32 ecast4;
        if ((ret = thrift_protocol_read_i32(protocol, &ecast4, error)) < 0)
          return -1;
        xfer += ret;
        this_object->operandType = (ColumnType)ecast4;
        this_object->__isset_operandType = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 arithmethic_operator_write(ThriftStruct *object,
                                         ThriftProtocol *protocol,
                                         GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  ArithmethicOperator *this_object = ARITHMETHIC_OPERATOR(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "ArithmethicOperator",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "operator", T_I32, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32(protocol, (gint32)this_object->operator,
                                       error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "operandType", T_I32,
                                               2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32(
           protocol, (gint32)this_object->operandType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void arithmethic_operator_set_property(GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec) {
  ArithmethicOperator *self = ARITHMETHIC_OPERATOR(object);

  switch (property_id) {
  case PROP_ARITHMETHIC_OPERATOR_OPERATOR:
    self->operator= g_value_get_int(value);
    self->__isset_operator = TRUE;
    break;

  case PROP_ARITHMETHIC_OPERATOR_OPERAND_TYPE:
    self->operandType = g_value_get_int(value);
    self->__isset_operandType = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void arithmethic_operator_get_property(GObject *object,
                                              guint property_id, GValue *value,
                                              GParamSpec *pspec) {
  ArithmethicOperator *self = ARITHMETHIC_OPERATOR(object);

  switch (property_id) {
  case PROP_ARITHMETHIC_OPERATOR_OPERATOR:
    g_value_set_int(value, self->operator);
    break;

  case PROP_ARITHMETHIC_OPERATOR_OPERAND_TYPE:
    g_value_set_int(value, self->operandType);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void arithmethic_operator_instance_init(ArithmethicOperator *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->__isset_operator = FALSE;
  object->__isset_operandType = FALSE;
}

static void arithmethic_operator_finalize(GObject *object) {
  ArithmethicOperator *tobject = ARITHMETHIC_OPERATOR(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
}

static void arithmethic_operator_class_init(ArithmethicOperatorClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = arithmethic_operator_read;
  struct_class->write = arithmethic_operator_write;

  gobject_class->finalize = arithmethic_operator_finalize;
  gobject_class->get_property = arithmethic_operator_get_property;
  gobject_class->set_property = arithmethic_operator_set_property;

  g_object_class_install_property(
      gobject_class, PROP_ARITHMETHIC_OPERATOR_OPERATOR,
      g_param_spec_int("operator", NULL, NULL, 0, 3, 0, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_ARITHMETHIC_OPERATOR_OPERAND_TYPE,
      g_param_spec_int("operandType", NULL, NULL, 0, 4, 0, G_PARAM_READWRITE));
}

GType arithmethic_operator_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(ArithmethicOperatorClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)arithmethic_operator_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(ArithmethicOperator),
        0, /* n_preallocs */
        (GInstanceInitFunc)arithmethic_operator_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "ArithmethicOperatorType",
                                  &type_info, 0);
  }

  return type;
}

enum _ComparisonOperatorProperties {
  PROP_COMPARISON_OPERATOR_0,
  PROP_COMPARISON_OPERATOR_OPEREATOR,
  PROP_COMPARISON_OPERATOR_OPEREAND_TYPE
};

/* reads a comparison_operator object */
static gint32 comparison_operator_read(ThriftStruct *object,
                                       ThriftProtocol *protocol,
                                       GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ComparisonOperator *this_object = COMPARISON_OPERATOR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_I32) {
        gint32 ecast5;
        if ((ret = thrift_protocol_read_i32(protocol, &ecast5, error)) < 0)
          return -1;
        xfer += ret;
        this_object->opereator = (ComparisonOperatorValue)ecast5;
        this_object->__isset_opereator = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_I32) {
        gint32 ecast6;
        if ((ret = thrift_protocol_read_i32(protocol, &ecast6, error)) < 0)
          return -1;
        xfer += ret;
        this_object->opereandType = (ColumnType)ecast6;
        this_object->__isset_opereandType = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 comparison_operator_write(ThriftStruct *object,
                                        ThriftProtocol *protocol,
                                        GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  ComparisonOperator *this_object = COMPARISON_OPERATOR(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "ComparisonOperator",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "opereator", T_I32, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32(protocol, (gint32)this_object->opereator,
                                       error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "opereandType", T_I32,
                                               2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32(
           protocol, (gint32)this_object->opereandType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void comparison_operator_set_property(GObject *object, guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec) {
  ComparisonOperator *self = COMPARISON_OPERATOR(object);

  switch (property_id) {
  case PROP_COMPARISON_OPERATOR_OPEREATOR:
    self->opereator = g_value_get_int(value);
    self->__isset_opereator = TRUE;
    break;

  case PROP_COMPARISON_OPERATOR_OPEREAND_TYPE:
    self->opereandType = g_value_get_int(value);
    self->__isset_opereandType = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void comparison_operator_get_property(GObject *object, guint property_id,
                                             GValue *value, GParamSpec *pspec) {
  ComparisonOperator *self = COMPARISON_OPERATOR(object);

  switch (property_id) {
  case PROP_COMPARISON_OPERATOR_OPEREATOR:
    g_value_set_int(value, self->opereator);
    break;

  case PROP_COMPARISON_OPERATOR_OPEREAND_TYPE:
    g_value_set_int(value, self->opereandType);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void comparison_operator_instance_init(ComparisonOperator *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->__isset_opereator = FALSE;
  object->__isset_opereandType = FALSE;
}

static void comparison_operator_finalize(GObject *object) {
  ComparisonOperator *tobject = COMPARISON_OPERATOR(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
}

static void comparison_operator_class_init(ComparisonOperatorClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = comparison_operator_read;
  struct_class->write = comparison_operator_write;

  gobject_class->finalize = comparison_operator_finalize;
  gobject_class->get_property = comparison_operator_get_property;
  gobject_class->set_property = comparison_operator_set_property;

  g_object_class_install_property(
      gobject_class, PROP_COMPARISON_OPERATOR_OPEREATOR,
      g_param_spec_int("opereator", NULL, NULL, 0, 5, 0, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_COMPARISON_OPERATOR_OPEREAND_TYPE,
      g_param_spec_int("opereandType", NULL, NULL, 0, 4, 0, G_PARAM_READWRITE));
}

GType comparison_operator_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(ComparisonOperatorClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)comparison_operator_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(ComparisonOperator),
        0, /* n_preallocs */
        (GInstanceInitFunc)comparison_operator_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "ComparisonOperatorType",
                                  &type_info, 0);
  }

  return type;
}

enum _LogicalOperatorProperties {
  PROP_LOGICAL_OPERATOR_0,
  PROP_LOGICAL_OPERATOR_OPERATOR
};

/* reads a logical_operator object */
static gint32 logical_operator_read(ThriftStruct *object,
                                    ThriftProtocol *protocol, GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LogicalOperator *this_object = LOGICAL_OPERATOR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_I32) {
        gint32 ecast7;
        if ((ret = thrift_protocol_read_i32(protocol, &ecast7, error)) < 0)
          return -1;
        xfer += ret;
        this_object->operator=(LogicalOperatorValue) ecast7;
        this_object->__isset_operator = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 logical_operator_write(ThriftStruct *object,
                                     ThriftProtocol *protocol, GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  LogicalOperator *this_object = LOGICAL_OPERATOR(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "LogicalOperator",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "operator", T_I32, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32(protocol, (gint32)this_object->operator,
                                       error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void logical_operator_set_property(GObject *object, guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec) {
  LogicalOperator *self = LOGICAL_OPERATOR(object);

  switch (property_id) {
  case PROP_LOGICAL_OPERATOR_OPERATOR:
    self->operator= g_value_get_int(value);
    self->__isset_operator = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void logical_operator_get_property(GObject *object, guint property_id,
                                          GValue *value, GParamSpec *pspec) {
  LogicalOperator *self = LOGICAL_OPERATOR(object);

  switch (property_id) {
  case PROP_LOGICAL_OPERATOR_OPERATOR:
    g_value_set_int(value, self->operator);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void logical_operator_instance_init(LogicalOperator *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->__isset_operator = FALSE;
}

static void logical_operator_finalize(GObject *object) {
  LogicalOperator *tobject = LOGICAL_OPERATOR(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
}

static void logical_operator_class_init(LogicalOperatorClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = logical_operator_read;
  struct_class->write = logical_operator_write;

  gobject_class->finalize = logical_operator_finalize;
  gobject_class->get_property = logical_operator_get_property;
  gobject_class->set_property = logical_operator_set_property;

  g_object_class_install_property(
      gobject_class, PROP_LOGICAL_OPERATOR_OPERATOR,
      g_param_spec_int("operator", NULL, NULL, 0, 2, 0, G_PARAM_READWRITE));
}

GType logical_operator_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(LogicalOperatorClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)logical_operator_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(LogicalOperator),
        0, /* n_preallocs */
        (GInstanceInitFunc)logical_operator_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "LogicalOperatorType",
                                  &type_info, 0);
  }

  return type;
}

enum _ExpressionOperatorProperties {
  PROP_EXPRESSION_OPERATOR_0,
  PROP_EXPRESSION_OPERATOR_ARITHMETHIC_OPER,
  PROP_EXPRESSION_OPERATOR_COMPAARISON_OPER,
  PROP_EXPRESSION_OPERATOR_LOGICAL_OPER
};

/* reads a expression_operator object */
static gint32 expression_operator_read(ThriftStruct *object,
                                       ThriftProtocol *protocol,
                                       GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ExpressionOperator *this_object = EXPRESSION_OPERATOR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRUCT) {
        if ((ret =
                 thrift_struct_read(THRIFT_STRUCT(this_object->arithmethicOper),
                                    protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_arithmethicOper = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_STRUCT) {
        if ((ret =
                 thrift_struct_read(THRIFT_STRUCT(this_object->compaarisonOper),
                                    protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_compaarisonOper = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 3:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->logicalOper),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_logicalOper = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 expression_operator_write(ThriftStruct *object,
                                        ThriftProtocol *protocol,
                                        GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  ExpressionOperator *this_object = EXPRESSION_OPERATOR(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "ExpressionOperator",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "arithmethicOper",
                                               T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->arithmethicOper),
                                 protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "compaarisonOper",
                                               T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->compaarisonOper),
                                 protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "logicalOper",
                                               T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->logicalOper),
                                 protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void expression_operator_set_property(GObject *object, guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec) {
  ExpressionOperator *self = EXPRESSION_OPERATOR(object);

  switch (property_id) {
  case PROP_EXPRESSION_OPERATOR_ARITHMETHIC_OPER:
    if (self->arithmethicOper != NULL)
      g_object_unref(self->arithmethicOper);
    self->arithmethicOper = g_value_dup_object(value);
    self->__isset_arithmethicOper = TRUE;
    break;

  case PROP_EXPRESSION_OPERATOR_COMPAARISON_OPER:
    if (self->compaarisonOper != NULL)
      g_object_unref(self->compaarisonOper);
    self->compaarisonOper = g_value_dup_object(value);
    self->__isset_compaarisonOper = TRUE;
    break;

  case PROP_EXPRESSION_OPERATOR_LOGICAL_OPER:
    if (self->logicalOper != NULL)
      g_object_unref(self->logicalOper);
    self->logicalOper = g_value_dup_object(value);
    self->__isset_logicalOper = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void expression_operator_get_property(GObject *object, guint property_id,
                                             GValue *value, GParamSpec *pspec) {
  ExpressionOperator *self = EXPRESSION_OPERATOR(object);

  switch (property_id) {
  case PROP_EXPRESSION_OPERATOR_ARITHMETHIC_OPER:
    g_value_set_object(value, self->arithmethicOper);
    break;

  case PROP_EXPRESSION_OPERATOR_COMPAARISON_OPER:
    g_value_set_object(value, self->compaarisonOper);
    break;

  case PROP_EXPRESSION_OPERATOR_LOGICAL_OPER:
    g_value_set_object(value, self->logicalOper);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void expression_operator_instance_init(ExpressionOperator *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->arithmethicOper = g_object_new(TYPE_ARITHMETHIC_OPERATOR, NULL);
  object->__isset_arithmethicOper = FALSE;
  object->compaarisonOper = g_object_new(TYPE_COMPARISON_OPERATOR, NULL);
  object->__isset_compaarisonOper = FALSE;
  object->logicalOper = g_object_new(TYPE_LOGICAL_OPERATOR, NULL);
  object->__isset_logicalOper = FALSE;
}

static void expression_operator_finalize(GObject *object) {
  ExpressionOperator *tobject = EXPRESSION_OPERATOR(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->arithmethicOper != NULL) {
    g_object_unref(tobject->arithmethicOper);
    tobject->arithmethicOper = NULL;
  }
  if (tobject->compaarisonOper != NULL) {
    g_object_unref(tobject->compaarisonOper);
    tobject->compaarisonOper = NULL;
  }
  if (tobject->logicalOper != NULL) {
    g_object_unref(tobject->logicalOper);
    tobject->logicalOper = NULL;
  }
}

static void expression_operator_class_init(ExpressionOperatorClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = expression_operator_read;
  struct_class->write = expression_operator_write;

  gobject_class->finalize = expression_operator_finalize;
  gobject_class->get_property = expression_operator_get_property;
  gobject_class->set_property = expression_operator_set_property;

  g_object_class_install_property(
      gobject_class, PROP_EXPRESSION_OPERATOR_ARITHMETHIC_OPER,
      g_param_spec_object("arithmethicOper", NULL, NULL,
                          TYPE_ARITHMETHIC_OPERATOR, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_EXPRESSION_OPERATOR_COMPAARISON_OPER,
      g_param_spec_object("compaarisonOper", NULL, NULL,
                          TYPE_COMPARISON_OPERATOR, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_EXPRESSION_OPERATOR_LOGICAL_OPER,
      g_param_spec_object("logicalOper", NULL, NULL, TYPE_LOGICAL_OPERATOR,
                          G_PARAM_READWRITE));
}

GType expression_operator_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(ExpressionOperatorClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)expression_operator_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(ExpressionOperator),
        0, /* n_preallocs */
        (GInstanceInitFunc)expression_operator_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "ExpressionOperatorType",
                                  &type_info, 0);
  }

  return type;
}

enum _LiteralExprProperties {
  PROP_LITERAL_EXPR_0,
  PROP_LITERAL_EXPR_VAL,
  PROP_LITERAL_EXPR_COLUMN_TYPE
};

/* reads a literal_expr object */
static gint32 literal_expr_read(ThriftStruct *object, ThriftProtocol *protocol,
                                GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LiteralExpr *this_object = LITERAL_EXPR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->val), protocol,
                                      error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_val = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_I32) {
        gint32 ecast8;
        if ((ret = thrift_protocol_read_i32(protocol, &ecast8, error)) < 0)
          return -1;
        xfer += ret;
        this_object->columnType = (ColumnType)ecast8;
        this_object->__isset_columnType = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 literal_expr_write(ThriftStruct *object, ThriftProtocol *protocol,
                                 GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  LiteralExpr *this_object = LITERAL_EXPR(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "LiteralExpr",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "val", T_STRUCT, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->val), protocol,
                                 error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "columnType", T_I32, 2,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32(
           protocol, (gint32)this_object->columnType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void literal_expr_set_property(GObject *object, guint property_id,
                                      const GValue *value, GParamSpec *pspec) {
  LiteralExpr *self = LITERAL_EXPR(object);

  switch (property_id) {
  case PROP_LITERAL_EXPR_VAL:
    if (self->val != NULL)
      g_object_unref(self->val);
    self->val = g_value_dup_object(value);
    self->__isset_val = TRUE;
    break;

  case PROP_LITERAL_EXPR_COLUMN_TYPE:
    self->columnType = g_value_get_int(value);
    self->__isset_columnType = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void literal_expr_get_property(GObject *object, guint property_id,
                                      GValue *value, GParamSpec *pspec) {
  LiteralExpr *self = LITERAL_EXPR(object);

  switch (property_id) {
  case PROP_LITERAL_EXPR_VAL:
    g_value_set_object(value, self->val);
    break;

  case PROP_LITERAL_EXPR_COLUMN_TYPE:
    g_value_set_int(value, self->columnType);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void literal_expr_instance_init(LiteralExpr *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->val = g_object_new(TYPE_COLUMN_VALUE, NULL);
  object->__isset_val = FALSE;
  object->__isset_columnType = FALSE;
}

static void literal_expr_finalize(GObject *object) {
  LiteralExpr *tobject = LITERAL_EXPR(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->val != NULL) {
    g_object_unref(tobject->val);
    tobject->val = NULL;
  }
}

static void literal_expr_class_init(LiteralExprClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = literal_expr_read;
  struct_class->write = literal_expr_write;

  gobject_class->finalize = literal_expr_finalize;
  gobject_class->get_property = literal_expr_get_property;
  gobject_class->set_property = literal_expr_set_property;

  g_object_class_install_property(gobject_class, PROP_LITERAL_EXPR_VAL,
                                  g_param_spec_object("val", NULL, NULL,
                                                      TYPE_COLUMN_VALUE,
                                                      G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_LITERAL_EXPR_COLUMN_TYPE,
      g_param_spec_int("columnType", NULL, NULL, 0, 4, 0, G_PARAM_READWRITE));
}

GType literal_expr_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(LiteralExprClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)literal_expr_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(LiteralExpr),
        0, /* n_preallocs */
        (GInstanceInitFunc)literal_expr_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "LiteralExprType",
                                  &type_info, 0);
  }

  return type;
}

enum _ColumnExprProperties {
  PROP_COLUMN_EXPR_0,
  PROP_COLUMN_EXPR_TABLE_NAME,
  PROP_COLUMN_EXPR_COLUMN_NAME,
  PROP_COLUMN_EXPR_COLUMN_TYPE
};

/* reads a column_expr object */
static gint32 column_expr_read(ThriftStruct *object, ThriftProtocol *protocol,
                               GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnExpr *this_object = COLUMN_EXPR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->tableName != NULL) {
          g_free(this_object->tableName);
          this_object->tableName = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->tableName, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_tableName = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_STRING) {
        if (this_object->columnName != NULL) {
          g_free(this_object->columnName);
          this_object->columnName = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->columnName, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_columnName = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 3:
      if (ftype == T_I32) {
        gint32 ecast9;
        if ((ret = thrift_protocol_read_i32(protocol, &ecast9, error)) < 0)
          return -1;
        xfer += ret;
        this_object->columnType = (ColumnType)ecast9;
        this_object->__isset_columnType = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 column_expr_write(ThriftStruct *object, ThriftProtocol *protocol,
                                GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  ColumnExpr *this_object = COLUMN_EXPR(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "ColumnExpr",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "tableName", T_STRING,
                                               1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->tableName,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "columnName", T_STRING,
                                               2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->columnName,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "columnType", T_I32, 3,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32(
           protocol, (gint32)this_object->columnType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void column_expr_set_property(GObject *object, guint property_id,
                                     const GValue *value, GParamSpec *pspec) {
  ColumnExpr *self = COLUMN_EXPR(object);

  switch (property_id) {
  case PROP_COLUMN_EXPR_TABLE_NAME:
    if (self->tableName != NULL)
      g_free(self->tableName);
    self->tableName = g_value_dup_string(value);
    self->__isset_tableName = TRUE;
    break;

  case PROP_COLUMN_EXPR_COLUMN_NAME:
    if (self->columnName != NULL)
      g_free(self->columnName);
    self->columnName = g_value_dup_string(value);
    self->__isset_columnName = TRUE;
    break;

  case PROP_COLUMN_EXPR_COLUMN_TYPE:
    self->columnType = g_value_get_int(value);
    self->__isset_columnType = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void column_expr_get_property(GObject *object, guint property_id,
                                     GValue *value, GParamSpec *pspec) {
  ColumnExpr *self = COLUMN_EXPR(object);

  switch (property_id) {
  case PROP_COLUMN_EXPR_TABLE_NAME:
    g_value_set_string(value, self->tableName);
    break;

  case PROP_COLUMN_EXPR_COLUMN_NAME:
    g_value_set_string(value, self->columnName);
    break;

  case PROP_COLUMN_EXPR_COLUMN_TYPE:
    g_value_set_int(value, self->columnType);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void column_expr_instance_init(ColumnExpr *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->columnName = NULL;
  object->__isset_columnName = FALSE;
  object->__isset_columnType = FALSE;
}

static void column_expr_finalize(GObject *object) {
  ColumnExpr *tobject = COLUMN_EXPR(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->tableName != NULL) {
    g_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->columnName != NULL) {
    g_free(tobject->columnName);
    tobject->columnName = NULL;
  }
}

static void column_expr_class_init(ColumnExprClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = column_expr_read;
  struct_class->write = column_expr_write;

  gobject_class->finalize = column_expr_finalize;
  gobject_class->get_property = column_expr_get_property;
  gobject_class->set_property = column_expr_set_property;

  g_object_class_install_property(
      gobject_class, PROP_COLUMN_EXPR_TABLE_NAME,
      g_param_spec_string("tableName", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_COLUMN_EXPR_COLUMN_NAME,
      g_param_spec_string("columnName", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_COLUMN_EXPR_COLUMN_TYPE,
      g_param_spec_int("columnType", NULL, NULL, 0, 4, 0, G_PARAM_READWRITE));
}

GType column_expr_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(ColumnExprClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)column_expr_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(ColumnExpr),
        0, /* n_preallocs */
        (GInstanceInitFunc)column_expr_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "ColumnExprType",
                                  &type_info, 0);
  }

  return type;
}

enum _ExpressionProperties {
  PROP_EXPRESSION_0,
  PROP_EXPRESSION_LITERAL,
  PROP_EXPRESSION_COLUMN
};

/* reads a expression object */
static gint32 expression_read(ThriftStruct *object, ThriftProtocol *protocol,
                              GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Expression *this_object = EXPRESSION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->literal),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_literal = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->column),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_column = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 expression_write(ThriftStruct *object, ThriftProtocol *protocol,
                               GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  Expression *this_object = EXPRESSION(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "Expression",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_literal == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "literal", T_STRUCT,
                                                 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->literal),
                                   protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "column", T_STRUCT,
                                                 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->column), protocol,
                                   error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void expression_set_property(GObject *object, guint property_id,
                                    const GValue *value, GParamSpec *pspec) {
  Expression *self = EXPRESSION(object);

  switch (property_id) {
  case PROP_EXPRESSION_LITERAL:
    if (self->literal != NULL)
      g_object_unref(self->literal);
    self->literal = g_value_dup_object(value);
    self->__isset_literal = TRUE;
    break;

  case PROP_EXPRESSION_COLUMN:
    if (self->column != NULL)
      g_object_unref(self->column);
    self->column = g_value_dup_object(value);
    self->__isset_column = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void expression_get_property(GObject *object, guint property_id,
                                    GValue *value, GParamSpec *pspec) {
  Expression *self = EXPRESSION(object);

  switch (property_id) {
  case PROP_EXPRESSION_LITERAL:
    g_value_set_object(value, self->literal);
    break;

  case PROP_EXPRESSION_COLUMN:
    g_value_set_object(value, self->column);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void expression_instance_init(Expression *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->literal = g_object_new(TYPE_LITERAL_EXPR, NULL);
  object->__isset_literal = FALSE;
  object->column = g_object_new(TYPE_COLUMN_EXPR, NULL);
  object->__isset_column = FALSE;
}

static void expression_finalize(GObject *object) {
  Expression *tobject = EXPRESSION(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->literal != NULL) {
    g_object_unref(tobject->literal);
    tobject->literal = NULL;
  }
  if (tobject->column != NULL) {
    g_object_unref(tobject->column);
    tobject->column = NULL;
  }
}

static void expression_class_init(ExpressionClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = expression_read;
  struct_class->write = expression_write;

  gobject_class->finalize = expression_finalize;
  gobject_class->get_property = expression_get_property;
  gobject_class->set_property = expression_set_property;

  g_object_class_install_property(gobject_class, PROP_EXPRESSION_LITERAL,
                                  g_param_spec_object("literal", NULL, NULL,
                                                      TYPE_LITERAL_EXPR,
                                                      G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_EXPRESSION_COLUMN,
                                  g_param_spec_object("column", NULL, NULL,
                                                      TYPE_COLUMN_EXPR,
                                                      G_PARAM_READWRITE));
}

GType expression_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(ExpressionClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)expression_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(Expression),
        0, /* n_preallocs */
        (GInstanceInitFunc)expression_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "ExpressionType",
                                  &type_info, 0);
  }

  return type;
}

enum _PredicateProperties { PROP_PREDICATE_0, PROP_PREDICATE_EXPRESSION };

/* reads a predicate object */
static gint32 predicate_read(ThriftStruct *object, ThriftProtocol *protocol,
                             GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Predicate *this_object = PREDICATE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->expression),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_expression = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 predicate_write(ThriftStruct *object, ThriftProtocol *protocol,
                              GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  Predicate *this_object = PREDICATE(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "Predicate", error)) <
      0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "expression", T_STRUCT,
                                               1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->expression),
                                 protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void predicate_set_property(GObject *object, guint property_id,
                                   const GValue *value, GParamSpec *pspec) {
  Predicate *self = PREDICATE(object);

  switch (property_id) {
  case PROP_PREDICATE_EXPRESSION:
    if (self->expression != NULL)
      g_object_unref(self->expression);
    self->expression = g_value_dup_object(value);
    self->__isset_expression = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void predicate_get_property(GObject *object, guint property_id,
                                   GValue *value, GParamSpec *pspec) {
  Predicate *self = PREDICATE(object);

  switch (property_id) {
  case PROP_PREDICATE_EXPRESSION:
    g_value_set_object(value, self->expression);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void predicate_instance_init(Predicate *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->expression = g_object_new(TYPE_EXPRESSION, NULL);
  object->__isset_expression = FALSE;
}

static void predicate_finalize(GObject *object) {
  Predicate *tobject = PREDICATE(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->expression != NULL) {
    g_object_unref(tobject->expression);
    tobject->expression = NULL;
  }
}

static void predicate_class_init(PredicateClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = predicate_read;
  struct_class->write = predicate_write;

  gobject_class->finalize = predicate_finalize;
  gobject_class->get_property = predicate_get_property;
  gobject_class->set_property = predicate_set_property;

  g_object_class_install_property(gobject_class, PROP_PREDICATE_EXPRESSION,
                                  g_param_spec_object("expression", NULL, NULL,
                                                      TYPE_EXPRESSION,
                                                      G_PARAM_READWRITE));
}

GType predicate_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(PredicateClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)predicate_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(Predicate),
        0, /* n_preallocs */
        (GInstanceInitFunc)predicate_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "PredicateType",
                                  &type_info, 0);
  }

  return type;
}

enum _JoinProperties { PROP_JOIN_0, PROP_JOIN_WHAT, PROP_JOIN_ON };

/* reads a join object */
static gint32 join_read(ThriftStruct *object, ThriftProtocol *protocol,
                        GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Join *this_object = JOIN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->what != NULL) {
          g_free(this_object->what);
          this_object->what = NULL;
        }

        if ((ret = thrift_protocol_read_string(protocol, &this_object->what,
                                               error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_what = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->on), protocol,
                                      error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_on = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 join_write(ThriftStruct *object, ThriftProtocol *protocol,
                         GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  Join *this_object = JOIN(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "Join", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "what", T_STRING, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->what, error)) <
      0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "on", T_STRUCT, 2,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->on), protocol,
                                 error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void join_set_property(GObject *object, guint property_id,
                              const GValue *value, GParamSpec *pspec) {
  Join *self = JOIN(object);

  switch (property_id) {
  case PROP_JOIN_WHAT:
    if (self->what != NULL)
      g_free(self->what);
    self->what = g_value_dup_string(value);
    self->__isset_what = TRUE;
    break;

  case PROP_JOIN_ON:
    if (self->on != NULL)
      g_object_unref(self->on);
    self->on = g_value_dup_object(value);
    self->__isset_on = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void join_get_property(GObject *object, guint property_id, GValue *value,
                              GParamSpec *pspec) {
  Join *self = JOIN(object);

  switch (property_id) {
  case PROP_JOIN_WHAT:
    g_value_set_string(value, self->what);
    break;

  case PROP_JOIN_ON:
    g_value_set_object(value, self->on);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void join_instance_init(Join *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->what = NULL;
  object->__isset_what = FALSE;
  object->on = g_object_new(TYPE_PREDICATE, NULL);
  object->__isset_on = FALSE;
}

static void join_finalize(GObject *object) {
  Join *tobject = JOIN(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->what != NULL) {
    g_free(tobject->what);
    tobject->what = NULL;
  }
  if (tobject->on != NULL) {
    g_object_unref(tobject->on);
    tobject->on = NULL;
  }
}

static void join_class_init(JoinClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = join_read;
  struct_class->write = join_write;

  gobject_class->finalize = join_finalize;
  gobject_class->get_property = join_get_property;
  gobject_class->set_property = join_set_property;

  g_object_class_install_property(
      gobject_class, PROP_JOIN_WHAT,
      g_param_spec_string("what", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_JOIN_ON,
      g_param_spec_object("on", NULL, NULL, TYPE_PREDICATE, G_PARAM_READWRITE));
}

GType join_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(JoinClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)join_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(Join),
        0, /* n_preallocs */
        (GInstanceInitFunc)join_instance_init,
        NULL, /* value_table */
    };

    type =
        g_type_register_static(THRIFT_TYPE_STRUCT, "JoinType", &type_info, 0);
  }

  return type;
}

enum _RecordProperties { PROP_RECORD_0, PROP_RECORD_COLUMN_VALUES };

/* reads a record object */
static gint32 record_read(ThriftStruct *object, ThriftProtocol *protocol,
                          GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Record *this_object = RECORD(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_LIST) {
        {
          guint32 size;
          guint32 i;
          ThriftType element_type;

          if ((ret = thrift_protocol_read_list_begin(protocol, &element_type,
                                                     &size, error)) < 0)
            return -1;
          xfer += ret;

          /* iterate through list elements */
          for (i = 0; i < size; i++) {
            ColumnValue *_elem10 = NULL;
            if (_elem10 != NULL) {
              g_object_unref(_elem10);
            }
            _elem10 = g_object_new(TYPE_COLUMN_VALUE, NULL);
            if ((ret = thrift_struct_read(THRIFT_STRUCT(_elem10), protocol,
                                          error)) < 0) {
              g_object_unref(_elem10);
              return -1;
            }
            xfer += ret;
            g_ptr_array_add(this_object->columnValues, _elem10);
          }
          if ((ret = thrift_protocol_read_list_end(protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
        this_object->__isset_columnValues = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 record_write(ThriftStruct *object, ThriftProtocol *protocol,
                           GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  Record *this_object = RECORD(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "Record", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "columnValues", T_LIST,
                                               1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i11;

    if ((ret = thrift_protocol_write_list_begin(
             protocol, T_STRUCT,
             (gint32)(this_object->columnValues ? this_object->columnValues->len
                                                : 0),
             error)) < 0)
      return -1;
    xfer += ret;
    for (i11 = 0;
         i11 < (this_object->columnValues ? this_object->columnValues->len : 0);
         i11++) {
      if ((ret = thrift_struct_write(
               THRIFT_STRUCT((g_ptr_array_index(
                   (GPtrArray *)this_object->columnValues, i11))),
               protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void record_set_property(GObject *object, guint property_id,
                                const GValue *value, GParamSpec *pspec) {
  Record *self = RECORD(object);

  switch (property_id) {
  case PROP_RECORD_COLUMN_VALUES:
    if (self->columnValues != NULL)
      g_ptr_array_unref(self->columnValues);
    self->columnValues = g_value_dup_boxed(value);
    self->__isset_columnValues = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void record_get_property(GObject *object, guint property_id,
                                GValue *value, GParamSpec *pspec) {
  Record *self = RECORD(object);

  switch (property_id) {
  case PROP_RECORD_COLUMN_VALUES:
    g_value_set_boxed(value, self->columnValues);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void record_instance_init(Record *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->columnValues = g_ptr_array_new_with_free_func(g_object_unref);
  object->__isset_columnValues = FALSE;
}

static void record_finalize(GObject *object) {
  Record *tobject = RECORD(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->columnValues != NULL) {
    g_ptr_array_unref(tobject->columnValues);
    tobject->columnValues = NULL;
  }
}

static void record_class_init(RecordClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = record_read;
  struct_class->write = record_write;

  gobject_class->finalize = record_finalize;
  gobject_class->get_property = record_get_property;
  gobject_class->set_property = record_set_property;

  g_object_class_install_property(gobject_class, PROP_RECORD_COLUMN_VALUES,
                                  g_param_spec_boxed("columnValues", NULL, NULL,
                                                     G_TYPE_PTR_ARRAY,
                                                     G_PARAM_READWRITE));
}

GType record_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(RecordClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)record_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(Record),
        0, /* n_preallocs */
        (GInstanceInitFunc)record_instance_init,
        NULL, /* value_table */
    };

    type =
        g_type_register_static(THRIFT_TYPE_STRUCT, "RecordType", &type_info, 0);
  }

  return type;
}

enum _RecordGroupProperties {
  PROP_RECORD_GROUP_0,
  PROP_RECORD_GROUP_SCHEMA,
  PROP_RECORD_GROUP_RECORDS
};

/* reads a record_group object */
static gint32 record_group_read(ThriftStruct *object, ThriftProtocol *protocol,
                                GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RecordGroup *this_object = RECORD_GROUP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->schema),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_schema = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_LIST) {
        {
          guint32 size;
          guint32 i;
          ThriftType element_type;

          if ((ret = thrift_protocol_read_list_begin(protocol, &element_type,
                                                     &size, error)) < 0)
            return -1;
          xfer += ret;

          /* iterate through list elements */
          for (i = 0; i < size; i++) {
            Record *_elem12 = NULL;
            if (_elem12 != NULL) {
              g_object_unref(_elem12);
            }
            _elem12 = g_object_new(TYPE_RECORD, NULL);
            if ((ret = thrift_struct_read(THRIFT_STRUCT(_elem12), protocol,
                                          error)) < 0) {
              g_object_unref(_elem12);
              return -1;
            }
            xfer += ret;
            g_ptr_array_add(this_object->records, _elem12);
          }
          if ((ret = thrift_protocol_read_list_end(protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
        this_object->__isset_records = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 record_group_write(ThriftStruct *object, ThriftProtocol *protocol,
                                 GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  RecordGroup *this_object = RECORD_GROUP(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "RecordGroup",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "schema", T_STRUCT, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->schema), protocol,
                                 error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "records", T_LIST, 2,
                                               error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i13;

    if ((ret = thrift_protocol_write_list_begin(
             protocol, T_STRUCT,
             (gint32)(this_object->records ? this_object->records->len : 0),
             error)) < 0)
      return -1;
    xfer += ret;
    for (i13 = 0; i13 < (this_object->records ? this_object->records->len : 0);
         i13++) {
      if ((ret = thrift_struct_write(
               THRIFT_STRUCT(
                   (g_ptr_array_index((GPtrArray *)this_object->records, i13))),
               protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void record_group_set_property(GObject *object, guint property_id,
                                      const GValue *value, GParamSpec *pspec) {
  RecordGroup *self = RECORD_GROUP(object);

  switch (property_id) {
  case PROP_RECORD_GROUP_SCHEMA:
    if (self->schema != NULL)
      g_object_unref(self->schema);
    self->schema = g_value_dup_object(value);
    self->__isset_schema = TRUE;
    break;

  case PROP_RECORD_GROUP_RECORDS:
    if (self->records != NULL)
      g_ptr_array_unref(self->records);
    self->records = g_value_dup_boxed(value);
    self->__isset_records = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void record_group_get_property(GObject *object, guint property_id,
                                      GValue *value, GParamSpec *pspec) {
  RecordGroup *self = RECORD_GROUP(object);

  switch (property_id) {
  case PROP_RECORD_GROUP_SCHEMA:
    g_value_set_object(value, self->schema);
    break;

  case PROP_RECORD_GROUP_RECORDS:
    g_value_set_boxed(value, self->records);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void record_group_instance_init(RecordGroup *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->schema = g_object_new(TYPE_TABLE_SCHEMA, NULL);
  object->__isset_schema = FALSE;
  object->records = g_ptr_array_new_with_free_func(g_object_unref);
  object->__isset_records = FALSE;
}

static void record_group_finalize(GObject *object) {
  RecordGroup *tobject = RECORD_GROUP(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->schema != NULL) {
    g_object_unref(tobject->schema);
    tobject->schema = NULL;
  }
  if (tobject->records != NULL) {
    g_ptr_array_unref(tobject->records);
    tobject->records = NULL;
  }
}

static void record_group_class_init(RecordGroupClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = record_group_read;
  struct_class->write = record_group_write;

  gobject_class->finalize = record_group_finalize;
  gobject_class->get_property = record_group_get_property;
  gobject_class->set_property = record_group_set_property;

  g_object_class_install_property(gobject_class, PROP_RECORD_GROUP_SCHEMA,
                                  g_param_spec_object("schema", NULL, NULL,
                                                      TYPE_TABLE_SCHEMA,
                                                      G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_RECORD_GROUP_RECORDS,
                                  g_param_spec_boxed("records", NULL, NULL,
                                                     G_TYPE_PTR_ARRAY,
                                                     G_PARAM_READWRITE));
}

GType record_group_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(RecordGroupClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)record_group_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(RecordGroup),
        0, /* n_preallocs */
        (GInstanceInitFunc)record_group_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "RecordGroupType",
                                  &type_info, 0);
  }

  return type;
}

enum _RecordUpdateProperties {
  PROP_RECORD_UPDATE_0,
  PROP_RECORD_UPDATE_TABLE_NAME,
  PROP_RECORD_UPDATE_COLUMN_SCHEMAS,
  PROP_RECORD_UPDATE_VALUES
};

/* reads a record_update object */
static gint32 record_update_read(ThriftStruct *object, ThriftProtocol *protocol,
                                 GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RecordUpdate *this_object = RECORD_UPDATE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->tableName != NULL) {
          g_free(this_object->tableName);
          this_object->tableName = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->tableName, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_tableName = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_LIST) {
        {
          guint32 size;
          guint32 i;
          ThriftType element_type;

          if ((ret = thrift_protocol_read_list_begin(protocol, &element_type,
                                                     &size, error)) < 0)
            return -1;
          xfer += ret;

          /* iterate through list elements */
          for (i = 0; i < size; i++) {
            ColumnSchema *_elem14 = NULL;
            if (_elem14 != NULL) {
              g_object_unref(_elem14);
            }
            _elem14 = g_object_new(TYPE_COLUMN_SCHEMA, NULL);
            if ((ret = thrift_struct_read(THRIFT_STRUCT(_elem14), protocol,
                                          error)) < 0) {
              g_object_unref(_elem14);
              return -1;
            }
            xfer += ret;
            g_ptr_array_add(this_object->columnSchemas, _elem14);
          }
          if ((ret = thrift_protocol_read_list_end(protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
        this_object->__isset_columnSchemas = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 3:
      if (ftype == T_LIST) {
        {
          guint32 size;
          guint32 i;
          ThriftType element_type;

          if ((ret = thrift_protocol_read_list_begin(protocol, &element_type,
                                                     &size, error)) < 0)
            return -1;
          xfer += ret;

          /* iterate through list elements */
          for (i = 0; i < size; i++) {
            Expression *_elem15 = NULL;
            if (_elem15 != NULL) {
              g_object_unref(_elem15);
            }
            _elem15 = g_object_new(TYPE_EXPRESSION, NULL);
            if ((ret = thrift_struct_read(THRIFT_STRUCT(_elem15), protocol,
                                          error)) < 0) {
              g_object_unref(_elem15);
              return -1;
            }
            xfer += ret;
            g_ptr_array_add(this_object->values, _elem15);
          }
          if ((ret = thrift_protocol_read_list_end(protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
        this_object->__isset_values = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 record_update_write(ThriftStruct *object,
                                  ThriftProtocol *protocol, GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  RecordUpdate *this_object = RECORD_UPDATE(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "RecordUpdate",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "tableName", T_STRING,
                                               1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->tableName,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "columnSchemas",
                                               T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i16;

    if ((ret = thrift_protocol_write_list_begin(
             protocol, T_STRUCT,
             (gint32)(this_object->columnSchemas
                          ? this_object->columnSchemas->len
                          : 0),
             error)) < 0)
      return -1;
    xfer += ret;
    for (i16 = 0;
         i16 <
         (this_object->columnSchemas ? this_object->columnSchemas->len : 0);
         i16++) {
      if ((ret = thrift_struct_write(
               THRIFT_STRUCT((g_ptr_array_index(
                   (GPtrArray *)this_object->columnSchemas, i16))),
               protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "values", T_LIST, 3,
                                               error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i17;

    if ((ret = thrift_protocol_write_list_begin(
             protocol, T_STRUCT,
             (gint32)(this_object->values ? this_object->values->len : 0),
             error)) < 0)
      return -1;
    xfer += ret;
    for (i17 = 0; i17 < (this_object->values ? this_object->values->len : 0);
         i17++) {
      if ((ret = thrift_struct_write(
               THRIFT_STRUCT(
                   (g_ptr_array_index((GPtrArray *)this_object->values, i17))),
               protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void record_update_set_property(GObject *object, guint property_id,
                                       const GValue *value, GParamSpec *pspec) {
  RecordUpdate *self = RECORD_UPDATE(object);

  switch (property_id) {
  case PROP_RECORD_UPDATE_TABLE_NAME:
    if (self->tableName != NULL)
      g_free(self->tableName);
    self->tableName = g_value_dup_string(value);
    self->__isset_tableName = TRUE;
    break;

  case PROP_RECORD_UPDATE_COLUMN_SCHEMAS:
    if (self->columnSchemas != NULL)
      g_ptr_array_unref(self->columnSchemas);
    self->columnSchemas = g_value_dup_boxed(value);
    self->__isset_columnSchemas = TRUE;
    break;

  case PROP_RECORD_UPDATE_VALUES:
    if (self->values != NULL)
      g_ptr_array_unref(self->values);
    self->values = g_value_dup_boxed(value);
    self->__isset_values = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void record_update_get_property(GObject *object, guint property_id,
                                       GValue *value, GParamSpec *pspec) {
  RecordUpdate *self = RECORD_UPDATE(object);

  switch (property_id) {
  case PROP_RECORD_UPDATE_TABLE_NAME:
    g_value_set_string(value, self->tableName);
    break;

  case PROP_RECORD_UPDATE_COLUMN_SCHEMAS:
    g_value_set_boxed(value, self->columnSchemas);
    break;

  case PROP_RECORD_UPDATE_VALUES:
    g_value_set_boxed(value, self->values);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void record_update_instance_init(RecordUpdate *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->columnSchemas = g_ptr_array_new_with_free_func(g_object_unref);
  object->__isset_columnSchemas = FALSE;
  object->values = g_ptr_array_new_with_free_func(g_object_unref);
  object->__isset_values = FALSE;
}

static void record_update_finalize(GObject *object) {
  RecordUpdate *tobject = RECORD_UPDATE(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->tableName != NULL) {
    g_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->columnSchemas != NULL) {
    g_ptr_array_unref(tobject->columnSchemas);
    tobject->columnSchemas = NULL;
  }
  if (tobject->values != NULL) {
    g_ptr_array_unref(tobject->values);
    tobject->values = NULL;
  }
}

static void record_update_class_init(RecordUpdateClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = record_update_read;
  struct_class->write = record_update_write;

  gobject_class->finalize = record_update_finalize;
  gobject_class->get_property = record_update_get_property;
  gobject_class->set_property = record_update_set_property;

  g_object_class_install_property(
      gobject_class, PROP_RECORD_UPDATE_TABLE_NAME,
      g_param_spec_string("tableName", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_RECORD_UPDATE_COLUMN_SCHEMAS,
      g_param_spec_boxed("columnSchemas", NULL, NULL, G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_RECORD_UPDATE_VALUES,
                                  g_param_spec_boxed("values", NULL, NULL,
                                                     G_TYPE_PTR_ARRAY,
                                                     G_PARAM_READWRITE));
}

GType record_update_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(RecordUpdateClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)record_update_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(RecordUpdate),
        0, /* n_preallocs */
        (GInstanceInitFunc)record_update_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "RecordUpdateType",
                                  &type_info, 0);
  }

  return type;
}

enum _CreateTableStmtProperties {
  PROP_CREATE_TABLE_STMT_0,
  PROP_CREATE_TABLE_STMT_SCHEMA
};

/* reads a create_table_stmt object */
static gint32 create_table_stmt_read(ThriftStruct *object,
                                     ThriftProtocol *protocol, GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CreateTableStmt *this_object = CREATE_TABLE_STMT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->schema),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_schema = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 create_table_stmt_write(ThriftStruct *object,
                                      ThriftProtocol *protocol,
                                      GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  CreateTableStmt *this_object = CREATE_TABLE_STMT(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "CreateTableStmt",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "schema", T_STRUCT, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->schema), protocol,
                                 error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void create_table_stmt_set_property(GObject *object, guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec) {
  CreateTableStmt *self = CREATE_TABLE_STMT(object);

  switch (property_id) {
  case PROP_CREATE_TABLE_STMT_SCHEMA:
    if (self->schema != NULL)
      g_object_unref(self->schema);
    self->schema = g_value_dup_object(value);
    self->__isset_schema = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void create_table_stmt_get_property(GObject *object, guint property_id,
                                           GValue *value, GParamSpec *pspec) {
  CreateTableStmt *self = CREATE_TABLE_STMT(object);

  switch (property_id) {
  case PROP_CREATE_TABLE_STMT_SCHEMA:
    g_value_set_object(value, self->schema);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void create_table_stmt_instance_init(CreateTableStmt *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->schema = g_object_new(TYPE_TABLE_SCHEMA, NULL);
  object->__isset_schema = FALSE;
}

static void create_table_stmt_finalize(GObject *object) {
  CreateTableStmt *tobject = CREATE_TABLE_STMT(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->schema != NULL) {
    g_object_unref(tobject->schema);
    tobject->schema = NULL;
  }
}

static void create_table_stmt_class_init(CreateTableStmtClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = create_table_stmt_read;
  struct_class->write = create_table_stmt_write;

  gobject_class->finalize = create_table_stmt_finalize;
  gobject_class->get_property = create_table_stmt_get_property;
  gobject_class->set_property = create_table_stmt_set_property;

  g_object_class_install_property(gobject_class, PROP_CREATE_TABLE_STMT_SCHEMA,
                                  g_param_spec_object("schema", NULL, NULL,
                                                      TYPE_TABLE_SCHEMA,
                                                      G_PARAM_READWRITE));
}

GType create_table_stmt_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(CreateTableStmtClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)create_table_stmt_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(CreateTableStmt),
        0, /* n_preallocs */
        (GInstanceInitFunc)create_table_stmt_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "CreateTableStmtType",
                                  &type_info, 0);
  }

  return type;
}

enum _DropTableStmtProperties {
  PROP_DROP_TABLE_STMT_0,
  PROP_DROP_TABLE_STMT_TABLE_NAME
};

/* reads a drop_table_stmt object */
static gint32 drop_table_stmt_read(ThriftStruct *object,
                                   ThriftProtocol *protocol, GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DropTableStmt *this_object = DROP_TABLE_STMT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->tableName != NULL) {
          g_free(this_object->tableName);
          this_object->tableName = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->tableName, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_tableName = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 drop_table_stmt_write(ThriftStruct *object,
                                    ThriftProtocol *protocol, GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  DropTableStmt *this_object = DROP_TABLE_STMT(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "DropTableStmt",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "tableName", T_STRING,
                                               1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->tableName,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void drop_table_stmt_set_property(GObject *object, guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec) {
  DropTableStmt *self = DROP_TABLE_STMT(object);

  switch (property_id) {
  case PROP_DROP_TABLE_STMT_TABLE_NAME:
    if (self->tableName != NULL)
      g_free(self->tableName);
    self->tableName = g_value_dup_string(value);
    self->__isset_tableName = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void drop_table_stmt_get_property(GObject *object, guint property_id,
                                         GValue *value, GParamSpec *pspec) {
  DropTableStmt *self = DROP_TABLE_STMT(object);

  switch (property_id) {
  case PROP_DROP_TABLE_STMT_TABLE_NAME:
    g_value_set_string(value, self->tableName);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void drop_table_stmt_instance_init(DropTableStmt *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
}

static void drop_table_stmt_finalize(GObject *object) {
  DropTableStmt *tobject = DROP_TABLE_STMT(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->tableName != NULL) {
    g_free(tobject->tableName);
    tobject->tableName = NULL;
  }
}

static void drop_table_stmt_class_init(DropTableStmtClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = drop_table_stmt_read;
  struct_class->write = drop_table_stmt_write;

  gobject_class->finalize = drop_table_stmt_finalize;
  gobject_class->get_property = drop_table_stmt_get_property;
  gobject_class->set_property = drop_table_stmt_set_property;

  g_object_class_install_property(
      gobject_class, PROP_DROP_TABLE_STMT_TABLE_NAME,
      g_param_spec_string("tableName", NULL, NULL, NULL, G_PARAM_READWRITE));
}

GType drop_table_stmt_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(DropTableStmtClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)drop_table_stmt_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(DropTableStmt),
        0, /* n_preallocs */
        (GInstanceInitFunc)drop_table_stmt_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "DropTableStmtType",
                                  &type_info, 0);
  }

  return type;
}

enum _QueryStmtProperties {
  PROP_QUERY_STMT_0,
  PROP_QUERY_STMT_FROM_TABLE,
  PROP_QUERY_STMT_WHERE,
  PROP_QUERY_STMT_JOINS
};

/* reads a query_stmt object */
static gint32 query_stmt_read(ThriftStruct *object, ThriftProtocol *protocol,
                              GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  QueryStmt *this_object = QUERY_STMT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->fromTable != NULL) {
          g_free(this_object->fromTable);
          this_object->fromTable = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->fromTable, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_fromTable = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->where),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_where = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 3:
      if (ftype == T_LIST) {
        {
          guint32 size;
          guint32 i;
          ThriftType element_type;

          if ((ret = thrift_protocol_read_list_begin(protocol, &element_type,
                                                     &size, error)) < 0)
            return -1;
          xfer += ret;

          /* iterate through list elements */
          for (i = 0; i < size; i++) {
            Join *_elem18 = NULL;
            if (_elem18 != NULL) {
              g_object_unref(_elem18);
            }
            _elem18 = g_object_new(TYPE_JOIN, NULL);
            if ((ret = thrift_struct_read(THRIFT_STRUCT(_elem18), protocol,
                                          error)) < 0) {
              g_object_unref(_elem18);
              return -1;
            }
            xfer += ret;
            g_ptr_array_add(this_object->joins, _elem18);
          }
          if ((ret = thrift_protocol_read_list_end(protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
        this_object->__isset_joins = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 query_stmt_write(ThriftStruct *object, ThriftProtocol *protocol,
                               GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  QueryStmt *this_object = QUERY_STMT(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "QueryStmt", error)) <
      0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "fromTable", T_STRING,
                                               1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->fromTable,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "where", T_STRUCT, 2,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->where), protocol,
                                 error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "joins", T_LIST, 3,
                                               error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i19;

    if ((ret = thrift_protocol_write_list_begin(
             protocol, T_STRUCT,
             (gint32)(this_object->joins ? this_object->joins->len : 0),
             error)) < 0)
      return -1;
    xfer += ret;
    for (i19 = 0; i19 < (this_object->joins ? this_object->joins->len : 0);
         i19++) {
      if ((ret = thrift_struct_write(
               THRIFT_STRUCT(
                   (g_ptr_array_index((GPtrArray *)this_object->joins, i19))),
               protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void query_stmt_set_property(GObject *object, guint property_id,
                                    const GValue *value, GParamSpec *pspec) {
  QueryStmt *self = QUERY_STMT(object);

  switch (property_id) {
  case PROP_QUERY_STMT_FROM_TABLE:
    if (self->fromTable != NULL)
      g_free(self->fromTable);
    self->fromTable = g_value_dup_string(value);
    self->__isset_fromTable = TRUE;
    break;

  case PROP_QUERY_STMT_WHERE:
    if (self->where != NULL)
      g_object_unref(self->where);
    self->where = g_value_dup_object(value);
    self->__isset_where = TRUE;
    break;

  case PROP_QUERY_STMT_JOINS:
    if (self->joins != NULL)
      g_ptr_array_unref(self->joins);
    self->joins = g_value_dup_boxed(value);
    self->__isset_joins = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void query_stmt_get_property(GObject *object, guint property_id,
                                    GValue *value, GParamSpec *pspec) {
  QueryStmt *self = QUERY_STMT(object);

  switch (property_id) {
  case PROP_QUERY_STMT_FROM_TABLE:
    g_value_set_string(value, self->fromTable);
    break;

  case PROP_QUERY_STMT_WHERE:
    g_value_set_object(value, self->where);
    break;

  case PROP_QUERY_STMT_JOINS:
    g_value_set_boxed(value, self->joins);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void query_stmt_instance_init(QueryStmt *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->fromTable = NULL;
  object->__isset_fromTable = FALSE;
  object->where = g_object_new(TYPE_PREDICATE, NULL);
  object->__isset_where = FALSE;
  object->joins = g_ptr_array_new_with_free_func(g_object_unref);
  object->__isset_joins = FALSE;
}

static void query_stmt_finalize(GObject *object) {
  QueryStmt *tobject = QUERY_STMT(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->fromTable != NULL) {
    g_free(tobject->fromTable);
    tobject->fromTable = NULL;
  }
  if (tobject->where != NULL) {
    g_object_unref(tobject->where);
    tobject->where = NULL;
  }
  if (tobject->joins != NULL) {
    g_ptr_array_unref(tobject->joins);
    tobject->joins = NULL;
  }
}

static void query_stmt_class_init(QueryStmtClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = query_stmt_read;
  struct_class->write = query_stmt_write;

  gobject_class->finalize = query_stmt_finalize;
  gobject_class->get_property = query_stmt_get_property;
  gobject_class->set_property = query_stmt_set_property;

  g_object_class_install_property(
      gobject_class, PROP_QUERY_STMT_FROM_TABLE,
      g_param_spec_string("fromTable", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_QUERY_STMT_WHERE,
                                  g_param_spec_object("where", NULL, NULL,
                                                      TYPE_PREDICATE,
                                                      G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_QUERY_STMT_JOINS,
                                  g_param_spec_boxed("joins", NULL, NULL,
                                                     G_TYPE_PTR_ARRAY,
                                                     G_PARAM_READWRITE));
}

GType query_stmt_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(QueryStmtClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)query_stmt_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(QueryStmt),
        0, /* n_preallocs */
        (GInstanceInitFunc)query_stmt_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "QueryStmtType",
                                  &type_info, 0);
  }

  return type;
}

enum _InsertStmtProperties {
  PROP_INSERT_STMT_0,
  PROP_INSERT_STMT_INTO,
  PROP_INSERT_STMT_RECORDS
};

/* reads a insert_stmt object */
static gint32 insert_stmt_read(ThriftStruct *object, ThriftProtocol *protocol,
                               GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  InsertStmt *this_object = INSERT_STMT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->into != NULL) {
          g_free(this_object->into);
          this_object->into = NULL;
        }

        if ((ret = thrift_protocol_read_string(protocol, &this_object->into,
                                               error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_into = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->records),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_records = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 insert_stmt_write(ThriftStruct *object, ThriftProtocol *protocol,
                                GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  InsertStmt *this_object = INSERT_STMT(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "InsertStmt",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "into", T_STRING, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->into, error)) <
      0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "records", T_STRUCT, 2,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->records), protocol,
                                 error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void insert_stmt_set_property(GObject *object, guint property_id,
                                     const GValue *value, GParamSpec *pspec) {
  InsertStmt *self = INSERT_STMT(object);

  switch (property_id) {
  case PROP_INSERT_STMT_INTO:
    if (self->into != NULL)
      g_free(self->into);
    self->into = g_value_dup_string(value);
    self->__isset_into = TRUE;
    break;

  case PROP_INSERT_STMT_RECORDS:
    if (self->records != NULL)
      g_object_unref(self->records);
    self->records = g_value_dup_object(value);
    self->__isset_records = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void insert_stmt_get_property(GObject *object, guint property_id,
                                     GValue *value, GParamSpec *pspec) {
  InsertStmt *self = INSERT_STMT(object);

  switch (property_id) {
  case PROP_INSERT_STMT_INTO:
    g_value_set_string(value, self->into);
    break;

  case PROP_INSERT_STMT_RECORDS:
    g_value_set_object(value, self->records);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void insert_stmt_instance_init(InsertStmt *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->into = NULL;
  object->__isset_into = FALSE;
  object->records = g_object_new(TYPE_RECORD_GROUP, NULL);
  object->__isset_records = FALSE;
}

static void insert_stmt_finalize(GObject *object) {
  InsertStmt *tobject = INSERT_STMT(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->into != NULL) {
    g_free(tobject->into);
    tobject->into = NULL;
  }
  if (tobject->records != NULL) {
    g_object_unref(tobject->records);
    tobject->records = NULL;
  }
}

static void insert_stmt_class_init(InsertStmtClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = insert_stmt_read;
  struct_class->write = insert_stmt_write;

  gobject_class->finalize = insert_stmt_finalize;
  gobject_class->get_property = insert_stmt_get_property;
  gobject_class->set_property = insert_stmt_set_property;

  g_object_class_install_property(
      gobject_class, PROP_INSERT_STMT_INTO,
      g_param_spec_string("into", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_INSERT_STMT_RECORDS,
                                  g_param_spec_object("records", NULL, NULL,
                                                      TYPE_RECORD_GROUP,
                                                      G_PARAM_READWRITE));
}

GType insert_stmt_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(InsertStmtClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)insert_stmt_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(InsertStmt),
        0, /* n_preallocs */
        (GInstanceInitFunc)insert_stmt_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "InsertStmtType",
                                  &type_info, 0);
  }

  return type;
}

enum _UpdateStmtProperties {
  PROP_UPDATE_STMT_0,
  PROP_UPDATE_STMT_WHAT,
  PROP_UPDATE_STMT_SET_VALUES,
  PROP_UPDATE_STMT_WHERE
};

/* reads a update_stmt object */
static gint32 update_stmt_read(ThriftStruct *object, ThriftProtocol *protocol,
                               GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UpdateStmt *this_object = UPDATE_STMT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->what != NULL) {
          g_free(this_object->what);
          this_object->what = NULL;
        }

        if ((ret = thrift_protocol_read_string(protocol, &this_object->what,
                                               error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_what = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->setValues),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_setValues = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 3:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->where),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_where = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 update_stmt_write(ThriftStruct *object, ThriftProtocol *protocol,
                                GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  UpdateStmt *this_object = UPDATE_STMT(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "UpdateStmt",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "what", T_STRING, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->what, error)) <
      0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "setValues", T_STRUCT,
                                               2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->setValues),
                                 protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "where", T_STRUCT, 3,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->where), protocol,
                                 error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void update_stmt_set_property(GObject *object, guint property_id,
                                     const GValue *value, GParamSpec *pspec) {
  UpdateStmt *self = UPDATE_STMT(object);

  switch (property_id) {
  case PROP_UPDATE_STMT_WHAT:
    if (self->what != NULL)
      g_free(self->what);
    self->what = g_value_dup_string(value);
    self->__isset_what = TRUE;
    break;

  case PROP_UPDATE_STMT_SET_VALUES:
    if (self->setValues != NULL)
      g_object_unref(self->setValues);
    self->setValues = g_value_dup_object(value);
    self->__isset_setValues = TRUE;
    break;

  case PROP_UPDATE_STMT_WHERE:
    if (self->where != NULL)
      g_object_unref(self->where);
    self->where = g_value_dup_object(value);
    self->__isset_where = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void update_stmt_get_property(GObject *object, guint property_id,
                                     GValue *value, GParamSpec *pspec) {
  UpdateStmt *self = UPDATE_STMT(object);

  switch (property_id) {
  case PROP_UPDATE_STMT_WHAT:
    g_value_set_string(value, self->what);
    break;

  case PROP_UPDATE_STMT_SET_VALUES:
    g_value_set_object(value, self->setValues);
    break;

  case PROP_UPDATE_STMT_WHERE:
    g_value_set_object(value, self->where);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void update_stmt_instance_init(UpdateStmt *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->what = NULL;
  object->__isset_what = FALSE;
  object->setValues = g_object_new(TYPE_RECORD_UPDATE, NULL);
  object->__isset_setValues = FALSE;
  object->where = g_object_new(TYPE_PREDICATE, NULL);
  object->__isset_where = FALSE;
}

static void update_stmt_finalize(GObject *object) {
  UpdateStmt *tobject = UPDATE_STMT(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->what != NULL) {
    g_free(tobject->what);
    tobject->what = NULL;
  }
  if (tobject->setValues != NULL) {
    g_object_unref(tobject->setValues);
    tobject->setValues = NULL;
  }
  if (tobject->where != NULL) {
    g_object_unref(tobject->where);
    tobject->where = NULL;
  }
}

static void update_stmt_class_init(UpdateStmtClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = update_stmt_read;
  struct_class->write = update_stmt_write;

  gobject_class->finalize = update_stmt_finalize;
  gobject_class->get_property = update_stmt_get_property;
  gobject_class->set_property = update_stmt_set_property;

  g_object_class_install_property(
      gobject_class, PROP_UPDATE_STMT_WHAT,
      g_param_spec_string("what", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_UPDATE_STMT_SET_VALUES,
                                  g_param_spec_object("setValues", NULL, NULL,
                                                      TYPE_RECORD_UPDATE,
                                                      G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_UPDATE_STMT_WHERE,
                                  g_param_spec_object("where", NULL, NULL,
                                                      TYPE_PREDICATE,
                                                      G_PARAM_READWRITE));
}

GType update_stmt_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(UpdateStmtClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)update_stmt_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(UpdateStmt),
        0, /* n_preallocs */
        (GInstanceInitFunc)update_stmt_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "UpdateStmtType",
                                  &type_info, 0);
  }

  return type;
}

enum _DeleteStmtProperties {
  PROP_DELETE_STMT_0,
  PROP_DELETE_STMT_FROM_TABLE,
  PROP_DELETE_STMT_WHERE
};

/* reads a delete_stmt object */
static gint32 delete_stmt_read(ThriftStruct *object, ThriftProtocol *protocol,
                               GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DeleteStmt *this_object = DELETE_STMT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRING) {
        if (this_object->fromTable != NULL) {
          g_free(this_object->fromTable);
          this_object->fromTable = NULL;
        }

        if ((ret = thrift_protocol_read_string(
                 protocol, &this_object->fromTable, error)) < 0)
          return -1;
        xfer += ret;
        this_object->__isset_fromTable = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->where),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_where = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 delete_stmt_write(ThriftStruct *object, ThriftProtocol *protocol,
                                GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  DeleteStmt *this_object = DELETE_STMT(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "DeleteStmt",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "fromTable", T_STRING,
                                               1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->fromTable,
                                          error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "where", T_STRUCT, 2,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->where), protocol,
                                 error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void delete_stmt_set_property(GObject *object, guint property_id,
                                     const GValue *value, GParamSpec *pspec) {
  DeleteStmt *self = DELETE_STMT(object);

  switch (property_id) {
  case PROP_DELETE_STMT_FROM_TABLE:
    if (self->fromTable != NULL)
      g_free(self->fromTable);
    self->fromTable = g_value_dup_string(value);
    self->__isset_fromTable = TRUE;
    break;

  case PROP_DELETE_STMT_WHERE:
    if (self->where != NULL)
      g_object_unref(self->where);
    self->where = g_value_dup_object(value);
    self->__isset_where = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void delete_stmt_get_property(GObject *object, guint property_id,
                                     GValue *value, GParamSpec *pspec) {
  DeleteStmt *self = DELETE_STMT(object);

  switch (property_id) {
  case PROP_DELETE_STMT_FROM_TABLE:
    g_value_set_string(value, self->fromTable);
    break;

  case PROP_DELETE_STMT_WHERE:
    g_value_set_object(value, self->where);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void delete_stmt_instance_init(DeleteStmt *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->fromTable = NULL;
  object->__isset_fromTable = FALSE;
  object->where = g_object_new(TYPE_PREDICATE, NULL);
  object->__isset_where = FALSE;
}

static void delete_stmt_finalize(GObject *object) {
  DeleteStmt *tobject = DELETE_STMT(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->fromTable != NULL) {
    g_free(tobject->fromTable);
    tobject->fromTable = NULL;
  }
  if (tobject->where != NULL) {
    g_object_unref(tobject->where);
    tobject->where = NULL;
  }
}

static void delete_stmt_class_init(DeleteStmtClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = delete_stmt_read;
  struct_class->write = delete_stmt_write;

  gobject_class->finalize = delete_stmt_finalize;
  gobject_class->get_property = delete_stmt_get_property;
  gobject_class->set_property = delete_stmt_set_property;

  g_object_class_install_property(
      gobject_class, PROP_DELETE_STMT_FROM_TABLE,
      g_param_spec_string("fromTable", NULL, NULL, NULL, G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_DELETE_STMT_WHERE,
                                  g_param_spec_object("where", NULL, NULL,
                                                      TYPE_PREDICATE,
                                                      G_PARAM_READWRITE));
}

GType delete_stmt_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(DeleteStmtClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)delete_stmt_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(DeleteStmt),
        0, /* n_preallocs */
        (GInstanceInitFunc)delete_stmt_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "DeleteStmtType",
                                  &type_info, 0);
  }

  return type;
}

enum _StatementProperties {
  PROP_STATEMENT_0,
  PROP_STATEMENT_CREATE_TABLE_STMT,
  PROP_STATEMENT_DROP_TABLE_STMT,
  PROP_STATEMENT_QUERY_STMT,
  PROP_STATEMENT_INSERT_STMT,
  PROP_STATEMENT_UPDATE_STMT,
  PROP_STATEMENT_DELETE_STMT
};

/* reads a statement object */
static gint32 statement_read(ThriftStruct *object, ThriftProtocol *protocol,
                             GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Statement *this_object = STATEMENT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRUCT) {
        if ((ret =
                 thrift_struct_read(THRIFT_STRUCT(this_object->createTableStmt),
                                    protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_createTableStmt = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->dropTableStmt),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_dropTableStmt = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 3:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->queryStmt),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_queryStmt = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 4:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->insertStmt),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_insertStmt = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 5:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->updateStmt),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_updateStmt = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 6:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->deleteStmt),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_deleteStmt = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 statement_write(ThriftStruct *object, ThriftProtocol *protocol,
                              GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  Statement *this_object = STATEMENT(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "Statement", error)) <
      0)
    return -1;
  xfer += ret;
  if (this_object->__isset_createTableStmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "createTableStmt",
                                                 T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->createTableStmt),
                                   protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_dropTableStmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "dropTableStmt",
                                                 T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->dropTableStmt),
                                   protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_queryStmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "queryStmt",
                                                 T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->queryStmt),
                                   protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_insertStmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "insertStmt",
                                                 T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->insertStmt),
                                   protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updateStmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "updateStmt",
                                                 T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->updateStmt),
                                   protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_deleteStmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "deleteStmt",
                                                 T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->deleteStmt),
                                   protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void statement_set_property(GObject *object, guint property_id,
                                   const GValue *value, GParamSpec *pspec) {
  Statement *self = STATEMENT(object);

  switch (property_id) {
  case PROP_STATEMENT_CREATE_TABLE_STMT:
    if (self->createTableStmt != NULL)
      g_object_unref(self->createTableStmt);
    self->createTableStmt = g_value_dup_object(value);
    self->__isset_createTableStmt = TRUE;
    break;

  case PROP_STATEMENT_DROP_TABLE_STMT:
    if (self->dropTableStmt != NULL)
      g_object_unref(self->dropTableStmt);
    self->dropTableStmt = g_value_dup_object(value);
    self->__isset_dropTableStmt = TRUE;
    break;

  case PROP_STATEMENT_QUERY_STMT:
    if (self->queryStmt != NULL)
      g_object_unref(self->queryStmt);
    self->queryStmt = g_value_dup_object(value);
    self->__isset_queryStmt = TRUE;
    break;

  case PROP_STATEMENT_INSERT_STMT:
    if (self->insertStmt != NULL)
      g_object_unref(self->insertStmt);
    self->insertStmt = g_value_dup_object(value);
    self->__isset_insertStmt = TRUE;
    break;

  case PROP_STATEMENT_UPDATE_STMT:
    if (self->updateStmt != NULL)
      g_object_unref(self->updateStmt);
    self->updateStmt = g_value_dup_object(value);
    self->__isset_updateStmt = TRUE;
    break;

  case PROP_STATEMENT_DELETE_STMT:
    if (self->deleteStmt != NULL)
      g_object_unref(self->deleteStmt);
    self->deleteStmt = g_value_dup_object(value);
    self->__isset_deleteStmt = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void statement_get_property(GObject *object, guint property_id,
                                   GValue *value, GParamSpec *pspec) {
  Statement *self = STATEMENT(object);

  switch (property_id) {
  case PROP_STATEMENT_CREATE_TABLE_STMT:
    g_value_set_object(value, self->createTableStmt);
    break;

  case PROP_STATEMENT_DROP_TABLE_STMT:
    g_value_set_object(value, self->dropTableStmt);
    break;

  case PROP_STATEMENT_QUERY_STMT:
    g_value_set_object(value, self->queryStmt);
    break;

  case PROP_STATEMENT_INSERT_STMT:
    g_value_set_object(value, self->insertStmt);
    break;

  case PROP_STATEMENT_UPDATE_STMT:
    g_value_set_object(value, self->updateStmt);
    break;

  case PROP_STATEMENT_DELETE_STMT:
    g_value_set_object(value, self->deleteStmt);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void statement_instance_init(Statement *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->createTableStmt = g_object_new(TYPE_CREATE_TABLE_STMT, NULL);
  object->__isset_createTableStmt = FALSE;
  object->dropTableStmt = g_object_new(TYPE_DROP_TABLE_STMT, NULL);
  object->__isset_dropTableStmt = FALSE;
  object->queryStmt = g_object_new(TYPE_QUERY_STMT, NULL);
  object->__isset_queryStmt = FALSE;
  object->insertStmt = g_object_new(TYPE_INSERT_STMT, NULL);
  object->__isset_insertStmt = FALSE;
  object->updateStmt = g_object_new(TYPE_UPDATE_STMT, NULL);
  object->__isset_updateStmt = FALSE;
  object->deleteStmt = g_object_new(TYPE_DELETE_STMT, NULL);
  object->__isset_deleteStmt = FALSE;
}

static void statement_finalize(GObject *object) {
  Statement *tobject = STATEMENT(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->createTableStmt != NULL) {
    g_object_unref(tobject->createTableStmt);
    tobject->createTableStmt = NULL;
  }
  if (tobject->dropTableStmt != NULL) {
    g_object_unref(tobject->dropTableStmt);
    tobject->dropTableStmt = NULL;
  }
  if (tobject->queryStmt != NULL) {
    g_object_unref(tobject->queryStmt);
    tobject->queryStmt = NULL;
  }
  if (tobject->insertStmt != NULL) {
    g_object_unref(tobject->insertStmt);
    tobject->insertStmt = NULL;
  }
  if (tobject->updateStmt != NULL) {
    g_object_unref(tobject->updateStmt);
    tobject->updateStmt = NULL;
  }
  if (tobject->deleteStmt != NULL) {
    g_object_unref(tobject->deleteStmt);
    tobject->deleteStmt = NULL;
  }
}

static void statement_class_init(StatementClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = statement_read;
  struct_class->write = statement_write;

  gobject_class->finalize = statement_finalize;
  gobject_class->get_property = statement_get_property;
  gobject_class->set_property = statement_set_property;

  g_object_class_install_property(
      gobject_class, PROP_STATEMENT_CREATE_TABLE_STMT,
      g_param_spec_object("createTableStmt", NULL, NULL, TYPE_CREATE_TABLE_STMT,
                          G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_STATEMENT_DROP_TABLE_STMT,
      g_param_spec_object("dropTableStmt", NULL, NULL, TYPE_DROP_TABLE_STMT,
                          G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_STATEMENT_QUERY_STMT,
                                  g_param_spec_object("queryStmt", NULL, NULL,
                                                      TYPE_QUERY_STMT,
                                                      G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_STATEMENT_INSERT_STMT,
                                  g_param_spec_object("insertStmt", NULL, NULL,
                                                      TYPE_INSERT_STMT,
                                                      G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_STATEMENT_UPDATE_STMT,
                                  g_param_spec_object("updateStmt", NULL, NULL,
                                                      TYPE_UPDATE_STMT,
                                                      G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_STATEMENT_DELETE_STMT,
                                  g_param_spec_object("deleteStmt", NULL, NULL,
                                                      TYPE_DELETE_STMT,
                                                      G_PARAM_READWRITE));
}

GType statement_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(StatementClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)statement_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(Statement),
        0, /* n_preallocs */
        (GInstanceInitFunc)statement_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "StatementType",
                                  &type_info, 0);
  }

  return type;
}

enum _RecordViewProperties {
  PROP_RECORD_VIEW_0,
  PROP_RECORD_VIEW_RECORDS,
  PROP_RECORD_VIEW_COLUMNS
};

/* reads a record_view object */
static gint32 record_view_read(ThriftStruct *object, ThriftProtocol *protocol,
                               GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RecordView *this_object = RECORD_VIEW(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_LIST) {
        {
          guint32 size;
          guint32 i;
          ThriftType element_type;

          if ((ret = thrift_protocol_read_list_begin(protocol, &element_type,
                                                     &size, error)) < 0)
            return -1;
          xfer += ret;

          /* iterate through list elements */
          for (i = 0; i < size; i++) {
            Record *_elem20 = NULL;
            if (_elem20 != NULL) {
              g_object_unref(_elem20);
            }
            _elem20 = g_object_new(TYPE_RECORD, NULL);
            if ((ret = thrift_struct_read(THRIFT_STRUCT(_elem20), protocol,
                                          error)) < 0) {
              g_object_unref(_elem20);
              return -1;
            }
            xfer += ret;
            g_ptr_array_add(this_object->records, _elem20);
          }
          if ((ret = thrift_protocol_read_list_end(protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
        this_object->__isset_records = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 2:
      if (ftype == T_LIST) {
        {
          guint32 size;
          guint32 i;
          ThriftType element_type;

          if ((ret = thrift_protocol_read_list_begin(protocol, &element_type,
                                                     &size, error)) < 0)
            return -1;
          xfer += ret;

          /* iterate through list elements */
          for (i = 0; i < size; i++) {
            ColumnSchema *_elem21 = NULL;
            if (_elem21 != NULL) {
              g_object_unref(_elem21);
            }
            _elem21 = g_object_new(TYPE_COLUMN_SCHEMA, NULL);
            if ((ret = thrift_struct_read(THRIFT_STRUCT(_elem21), protocol,
                                          error)) < 0) {
              g_object_unref(_elem21);
              return -1;
            }
            xfer += ret;
            g_ptr_array_add(this_object->columns, _elem21);
          }
          if ((ret = thrift_protocol_read_list_end(protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
        this_object->__isset_columns = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 record_view_write(ThriftStruct *object, ThriftProtocol *protocol,
                                GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  RecordView *this_object = RECORD_VIEW(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "RecordView",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "records", T_LIST, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i22;

    if ((ret = thrift_protocol_write_list_begin(
             protocol, T_STRUCT,
             (gint32)(this_object->records ? this_object->records->len : 0),
             error)) < 0)
      return -1;
    xfer += ret;
    for (i22 = 0; i22 < (this_object->records ? this_object->records->len : 0);
         i22++) {
      if ((ret = thrift_struct_write(
               THRIFT_STRUCT(
                   (g_ptr_array_index((GPtrArray *)this_object->records, i22))),
               protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "columns", T_LIST, 2,
                                               error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i23;

    if ((ret = thrift_protocol_write_list_begin(
             protocol, T_STRUCT,
             (gint32)(this_object->columns ? this_object->columns->len : 0),
             error)) < 0)
      return -1;
    xfer += ret;
    for (i23 = 0; i23 < (this_object->columns ? this_object->columns->len : 0);
         i23++) {
      if ((ret = thrift_struct_write(
               THRIFT_STRUCT(
                   (g_ptr_array_index((GPtrArray *)this_object->columns, i23))),
               protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void record_view_set_property(GObject *object, guint property_id,
                                     const GValue *value, GParamSpec *pspec) {
  RecordView *self = RECORD_VIEW(object);

  switch (property_id) {
  case PROP_RECORD_VIEW_RECORDS:
    if (self->records != NULL)
      g_ptr_array_unref(self->records);
    self->records = g_value_dup_boxed(value);
    self->__isset_records = TRUE;
    break;

  case PROP_RECORD_VIEW_COLUMNS:
    if (self->columns != NULL)
      g_ptr_array_unref(self->columns);
    self->columns = g_value_dup_boxed(value);
    self->__isset_columns = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void record_view_get_property(GObject *object, guint property_id,
                                     GValue *value, GParamSpec *pspec) {
  RecordView *self = RECORD_VIEW(object);

  switch (property_id) {
  case PROP_RECORD_VIEW_RECORDS:
    g_value_set_boxed(value, self->records);
    break;

  case PROP_RECORD_VIEW_COLUMNS:
    g_value_set_boxed(value, self->columns);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void record_view_instance_init(RecordView *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->records = g_ptr_array_new_with_free_func(g_object_unref);
  object->__isset_records = FALSE;
  object->columns = g_ptr_array_new_with_free_func(g_object_unref);
  object->__isset_columns = FALSE;
}

static void record_view_finalize(GObject *object) {
  RecordView *tobject = RECORD_VIEW(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->records != NULL) {
    g_ptr_array_unref(tobject->records);
    tobject->records = NULL;
  }
  if (tobject->columns != NULL) {
    g_ptr_array_unref(tobject->columns);
    tobject->columns = NULL;
  }
}

static void record_view_class_init(RecordViewClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = record_view_read;
  struct_class->write = record_view_write;

  gobject_class->finalize = record_view_finalize;
  gobject_class->get_property = record_view_get_property;
  gobject_class->set_property = record_view_set_property;

  g_object_class_install_property(gobject_class, PROP_RECORD_VIEW_RECORDS,
                                  g_param_spec_boxed("records", NULL, NULL,
                                                     G_TYPE_PTR_ARRAY,
                                                     G_PARAM_READWRITE));

  g_object_class_install_property(gobject_class, PROP_RECORD_VIEW_COLUMNS,
                                  g_param_spec_boxed("columns", NULL, NULL,
                                                     G_TYPE_PTR_ARRAY,
                                                     G_PARAM_READWRITE));
}

GType record_view_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(RecordViewClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)record_view_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(RecordView),
        0, /* n_preallocs */
        (GInstanceInitFunc)record_view_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "RecordViewType",
                                  &type_info, 0);
  }

  return type;
}

enum _StatementResultProperties {
  PROP_STATEMENT_RESULT_0,
  PROP_STATEMENT_RESULT_VIEW
};

/* reads a statement_result object */
static gint32 statement_result_read(ThriftStruct *object,
                                    ThriftProtocol *protocol, GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  StatementResult *this_object = STATEMENT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->view),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_view = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 statement_result_write(ThriftStruct *object,
                                     ThriftProtocol *protocol, GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  StatementResult *this_object = STATEMENT_RESULT(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(protocol, "StatementResult",
                                                error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "view", T_STRUCT, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->view), protocol,
                                 error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void statement_result_set_property(GObject *object, guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec) {
  StatementResult *self = STATEMENT_RESULT(object);

  switch (property_id) {
  case PROP_STATEMENT_RESULT_VIEW:
    if (self->view != NULL)
      g_object_unref(self->view);
    self->view = g_value_dup_object(value);
    self->__isset_view = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void statement_result_get_property(GObject *object, guint property_id,
                                          GValue *value, GParamSpec *pspec) {
  StatementResult *self = STATEMENT_RESULT(object);

  switch (property_id) {
  case PROP_STATEMENT_RESULT_VIEW:
    g_value_set_object(value, self->view);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void statement_result_instance_init(StatementResult *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->view = g_object_new(TYPE_RECORD_VIEW, NULL);
  object->__isset_view = FALSE;
}

static void statement_result_finalize(GObject *object) {
  StatementResult *tobject = STATEMENT_RESULT(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->view != NULL) {
    g_object_unref(tobject->view);
    tobject->view = NULL;
  }
}

static void statement_result_class_init(StatementResultClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = statement_result_read;
  struct_class->write = statement_result_write;

  gobject_class->finalize = statement_result_finalize;
  gobject_class->get_property = statement_result_get_property;
  gobject_class->set_property = statement_result_set_property;

  g_object_class_install_property(gobject_class, PROP_STATEMENT_RESULT_VIEW,
                                  g_param_spec_object("view", NULL, NULL,
                                                      TYPE_RECORD_VIEW,
                                                      G_PARAM_READWRITE));
}

GType statement_result_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(StatementResultClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)statement_result_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(StatementResult),
        0, /* n_preallocs */
        (GInstanceInitFunc)statement_result_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(THRIFT_TYPE_STRUCT, "StatementResultType",
                                  &type_info, 0);
  }

  return type;
}

/* constants */

enum _DatabaseServiceExecuteArgsProperties {
  PROP_DATABASE_SERVICE_EXECUTE_ARGS_0,
  PROP_DATABASE_SERVICE_EXECUTE_ARGS_STMT
};

/* reads a database_service_execute_args object */
static gint32 database_service_execute_args_read(ThriftStruct *object,
                                                 ThriftProtocol *protocol,
                                                 GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DatabaseServiceExecuteArgs *this_object =
      DATABASE_SERVICE_EXECUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 1:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->stmt),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_stmt = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 database_service_execute_args_write(ThriftStruct *object,
                                                  ThriftProtocol *protocol,
                                                  GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  DatabaseServiceExecuteArgs *this_object =
      DATABASE_SERVICE_EXECUTE_ARGS(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(
           protocol, "DatabaseServiceExecuteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin(protocol, "stmt", T_STRUCT, 1,
                                               error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->stmt), protocol,
                                 error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void database_service_execute_args_set_property(GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec) {
  DatabaseServiceExecuteArgs *self = DATABASE_SERVICE_EXECUTE_ARGS(object);

  switch (property_id) {
  case PROP_DATABASE_SERVICE_EXECUTE_ARGS_STMT:
    if (self->stmt != NULL)
      g_object_unref(self->stmt);
    self->stmt = g_value_dup_object(value);
    self->__isset_stmt = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void database_service_execute_args_get_property(GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec) {
  DatabaseServiceExecuteArgs *self = DATABASE_SERVICE_EXECUTE_ARGS(object);

  switch (property_id) {
  case PROP_DATABASE_SERVICE_EXECUTE_ARGS_STMT:
    g_value_set_object(value, self->stmt);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void database_service_execute_args_instance_init(
    DatabaseServiceExecuteArgs *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->stmt = g_object_new(TYPE_STATEMENT, NULL);
  object->__isset_stmt = FALSE;
}

static void database_service_execute_args_finalize(GObject *object) {
  DatabaseServiceExecuteArgs *tobject = DATABASE_SERVICE_EXECUTE_ARGS(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->stmt != NULL) {
    g_object_unref(tobject->stmt);
    tobject->stmt = NULL;
  }
}

static void
database_service_execute_args_class_init(DatabaseServiceExecuteArgsClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = database_service_execute_args_read;
  struct_class->write = database_service_execute_args_write;

  gobject_class->finalize = database_service_execute_args_finalize;
  gobject_class->get_property = database_service_execute_args_get_property;
  gobject_class->set_property = database_service_execute_args_set_property;

  g_object_class_install_property(
      gobject_class, PROP_DATABASE_SERVICE_EXECUTE_ARGS_STMT,
      g_param_spec_object("stmt", NULL, NULL, TYPE_STATEMENT,
                          G_PARAM_READWRITE));
}

GType database_service_execute_args_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(DatabaseServiceExecuteArgsClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)database_service_execute_args_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(DatabaseServiceExecuteArgs),
        0, /* n_preallocs */
        (GInstanceInitFunc)database_service_execute_args_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(
        THRIFT_TYPE_STRUCT, "DatabaseServiceExecuteArgsType", &type_info, 0);
  }

  return type;
}

enum _DatabaseServiceExecuteResultProperties {
  PROP_DATABASE_SERVICE_EXECUTE_RESULT_0,
  PROP_DATABASE_SERVICE_EXECUTE_RESULT_SUCCESS,
  PROP_DATABASE_SERVICE_EXECUTE_RESULT_ERR
};

/* reads a database_service_execute_result object */
static gint32 database_service_execute_result_read(ThriftStruct *object,
                                                   ThriftProtocol *protocol,
                                                   GError **error) {
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DatabaseServiceExecuteResult *this_object =
      DATABASE_SERVICE_EXECUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR(len);
  THRIFT_UNUSED_VAR(data);
  THRIFT_UNUSED_VAR(this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin(protocol, &name, error)) < 0) {
    if (name)
      g_free(name);
    return -1;
  }
  xfer += ret;
  if (name)
    g_free(name);
  name = NULL;

  /* read the struct fields */
  while (1) {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin(protocol, &name, &ftype, &fid,
                                                error)) < 0) {
      if (name)
        g_free(name);
      return -1;
    }
    xfer += ret;
    if (name)
      g_free(name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP) {
      break;
    }

    switch (fid) {
    case 0:
      if (ftype == T_STRUCT) {
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->success),
                                      protocol, error)) < 0) {
          return -1;
        }
        xfer += ret;
        this_object->__isset_success = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    case 1:
      if (ftype == T_STRUCT) {
        /* This struct is an exception */
        if (this_object->err != NULL) {
          g_object_unref(this_object->err);
        }
        this_object->err = g_object_new(TYPE_ERROR, NULL);
        if ((ret = thrift_struct_read(THRIFT_STRUCT(this_object->err), protocol,
                                      error)) < 0) {
          g_object_unref(this_object->err);
          this_object->err = NULL;
          return -1;
        }
        xfer += ret;
        this_object->__isset_err = TRUE;
      } else {
        if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
      }
      break;
    default:
      if ((ret = thrift_protocol_skip(protocol, ftype, error)) < 0)
        return -1;
      xfer += ret;
      break;
    }
    if ((ret = thrift_protocol_read_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32 database_service_execute_result_write(ThriftStruct *object,
                                                    ThriftProtocol *protocol,
                                                    GError **error) {
  gint32 ret;
  gint32 xfer = 0;

  DatabaseServiceExecuteResult *this_object =
      DATABASE_SERVICE_EXECUTE_RESULT(object);
  THRIFT_UNUSED_VAR(this_object);
  if ((ret = thrift_protocol_write_struct_begin(
           protocol, "DatabaseServiceExecuteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "success", T_STRUCT,
                                                 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->success),
                                   protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_err == TRUE) {
    if ((ret = thrift_protocol_write_field_begin(protocol, "err", T_STRUCT, 1,
                                                 error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write(THRIFT_STRUCT(this_object->err), protocol,
                                   error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void database_service_execute_result_set_property(GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec) {
  DatabaseServiceExecuteResult *self = DATABASE_SERVICE_EXECUTE_RESULT(object);

  switch (property_id) {
  case PROP_DATABASE_SERVICE_EXECUTE_RESULT_SUCCESS:
    if (self->success != NULL)
      g_object_unref(self->success);
    self->success = g_value_dup_object(value);
    self->__isset_success = TRUE;
    break;

  case PROP_DATABASE_SERVICE_EXECUTE_RESULT_ERR:
    if (self->err != NULL)
      g_object_unref(self->err);
    self->err = g_value_dup_object(value);
    self->__isset_err = TRUE;
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void database_service_execute_result_get_property(GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec) {
  DatabaseServiceExecuteResult *self = DATABASE_SERVICE_EXECUTE_RESULT(object);

  switch (property_id) {
  case PROP_DATABASE_SERVICE_EXECUTE_RESULT_SUCCESS:
    g_value_set_object(value, self->success);
    break;

  case PROP_DATABASE_SERVICE_EXECUTE_RESULT_ERR:
    g_value_set_object(value, self->err);
    break;

  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
    break;
  }
}

static void database_service_execute_result_instance_init(
    DatabaseServiceExecuteResult *object) {
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR(object);
  object->success = g_object_new(TYPE_STATEMENT_RESULT, NULL);
  object->__isset_success = FALSE;
  object->err = NULL;
  object->__isset_err = FALSE;
}

static void database_service_execute_result_finalize(GObject *object) {
  DatabaseServiceExecuteResult *tobject =
      DATABASE_SERVICE_EXECUTE_RESULT(object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR(tobject);
  if (tobject->success != NULL) {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->err != NULL) {
    g_object_unref(tobject->err);
    tobject->err = NULL;
  }
}

static void database_service_execute_result_class_init(
    DatabaseServiceExecuteResultClass *cls) {
  GObjectClass *gobject_class = G_OBJECT_CLASS(cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS(cls);

  struct_class->read = database_service_execute_result_read;
  struct_class->write = database_service_execute_result_write;

  gobject_class->finalize = database_service_execute_result_finalize;
  gobject_class->get_property = database_service_execute_result_get_property;
  gobject_class->set_property = database_service_execute_result_set_property;

  g_object_class_install_property(
      gobject_class, PROP_DATABASE_SERVICE_EXECUTE_RESULT_SUCCESS,
      g_param_spec_object("success", NULL, NULL, TYPE_STATEMENT_RESULT,
                          G_PARAM_READWRITE));

  g_object_class_install_property(
      gobject_class, PROP_DATABASE_SERVICE_EXECUTE_RESULT_ERR,
      g_param_spec_object("err", NULL, NULL, TYPE_ERROR, G_PARAM_READWRITE));
}

GType database_service_execute_result_get_type(void) {
  static GType type = 0;

  if (type == 0) {
    static const GTypeInfo type_info = {
        sizeof(DatabaseServiceExecuteResultClass),
        NULL, /* base_init */
        NULL, /* base_finalize */
        (GClassInitFunc)database_service_execute_result_class_init,
        NULL, /* class_finalize */
        NULL, /* class_data */
        sizeof(DatabaseServiceExecuteResult),
        0, /* n_preallocs */
        (GInstanceInitFunc)database_service_execute_result_instance_init,
        NULL, /* value_table */
    };

    type = g_type_register_static(
        THRIFT_TYPE_STRUCT, "DatabaseServiceExecuteResultType", &type_info, 0);
  }

  return type;
}
